<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description></description>
    <link>twolun.github.com/</link>
    <atom:link href="twolun.github.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 13 May 2016 00:01:37 +0800</pubDate>
    <lastBuildDate>Fri, 13 May 2016 00:01:37 +0800</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>谈一谈JavaScript中的动态this值</title>
        <description>&lt;p&gt;对于大部分的JavaScript初学者而言，该语言中的&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;臭名狼籍。JavaScript中的&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;
值取决于它被调用的时机。本文，我们就来讨论一下这个奇怪的特性。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;this&quot;&gt;令人烦恼的动态&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;在JavaScript中，&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;的动态特性总是令人烦恼。对于新手而言，总是不知道如何去判断当前的&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;值。&lt;/p&gt;

&lt;p&gt;事实是，&lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS/tree/master/this%20%26%20object%20prototypes&quot;&gt;规则非常的简单&lt;/a&gt;。
我们先看一个例子：&lt;/p&gt;

&lt;p&gt;```javascript&lt;/p&gt;

&lt;p&gt;“use strict”;&lt;/p&gt;

&lt;p&gt;const polyglot = {
    name : “Weiwei SUN”,
    languages : [“Chinese”, “English”, “Italian”, “German”, “Polish”],
    introduce : function () {
        // this.name is “Weiwei SUN”
        const self = this;
        this.languages.forEach(function(language) {
            // this.name is undefined, so we have to use our saved “self” variable 
            console.log(“My name is “ + self.name + “, and I speak “ + language + “.”);
        });
    }
}&lt;/p&gt;

&lt;p&gt;polyglot.introduce();
```&lt;/p&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;introduce&lt;/code&gt;中，&lt;code class=&quot;highlighter-rouge&quot;&gt;this.name&lt;/code&gt;的值为&lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;。在回调函数的外部，
在我们的&lt;code class=&quot;highlighter-rouge&quot;&gt;forEach&lt;/code&gt;循环中，它指向&lt;code class=&quot;highlighter-rouge&quot;&gt;polyglot&lt;/code&gt;对象。在多数情况下，我们的直觉会告诉我们，
回调函数中的&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;和回调函数外部的&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;应该是指向同一个对象，然而事实缺并非如此。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在JavaScript中，&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;始终指向当前函数的调用者。所有的回调函数在事件循环中被调用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;还有一个相似的例子是构造了一个高阶函数的情况，此时内函数与外函数的&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;指向也会不同。
例如，下面这个例子：&lt;/p&gt;

&lt;p&gt;```javascript
var BindingMixin = {
    handleChange: function (key) {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // 此时this值会被解释器重新设置，从而丢失原来的this值
    var that = this;
    
    return function (event) {
      var newState = {};
      that.setState(newState);
    }
  } } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;问题在于，在JavaScript中，函数中的&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;总是取决于它们的实际调用者，
大体上可以包括&lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS/blob/master/this%20&amp;amp;%20object%20prototypes/ch2.md&quot;&gt;四个规则&lt;/a&gt;。
这个机制就是所谓的动态&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这意味着，当JavaScript解释器寻找&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;的值的时候，它将会找到其中的一个，
但对于回调函数的而言，其内部的&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;和外部的&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;却并非同一个。一般有两种解决方案：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;将&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;作为外部函数的局部变量进行保存，通常命名为&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;，正如上面的例子中展示的那样，
然后在内函数中。&lt;/li&gt;
  &lt;li&gt;在内函数中调用&lt;code class=&quot;highlighter-rouge&quot;&gt;bind()&lt;/code&gt;方法，用于设定&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;的值。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这些方法虽然有效，但却有点晦涩。&lt;/p&gt;

&lt;p&gt;或者，我们换一种思路，哪函数不再设置它们的&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;值，JavaScript将会寻找&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;的值。
就像寻找其他变量的值那样：逐层返回到上一层作用域中寻找，直到发现同名变量。这样的话，
我们就可以正确的使用到&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;变量的值，也就是所谓的 词法的&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;this-1&quot;&gt;使用箭头函数来实现 词法的&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;从ES2015开始，我们可以这么做了。箭头函数并不会绑定&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;值，从而允许我们利用&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;关键字的词法绑定。
我们可以对上面的代码进行重构：&lt;/p&gt;

&lt;p&gt;```javascript
“use strict”;&lt;/p&gt;

&lt;p&gt;let polyglot = {
    name : “Weiwei SUN”,
    languages : [“Chinese”, “English”, “Italian”, “German”, “Polish”],
    introduce : function () {
        this.languages.forEach((language) =&amp;gt; {
            console.log(“My name is “ + this.name + “, and I speak “ + language + “.”);
        });
    }
}&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;现在，代码的运行结果正如我们所期望的那样。&lt;/p&gt;

&lt;p&gt;箭头函数的使用大概有以下几种类型：&lt;/p&gt;

&lt;p&gt;```javascript
“use strict”;&lt;/p&gt;

&lt;p&gt;let languages = [“Spanish”, “French”, “Italian”, “German”, “Polish”];&lt;/p&gt;

&lt;p&gt;// 在多行箭头函数中，你必须使用花括号，
//  并且你必须包含一个return语句
let languages_lower = languages.map((language) =&amp;gt; {
    return language.toLowerCase()
});&lt;/p&gt;

&lt;p&gt;// 如果是单行的箭头函数，那么花括号则是可选的
//  并且函数会隐式的返回表达式，
//  你可以显示的提供return语句
let languages_lower = languages.map((language) =&amp;gt; language.toLowerCase());&lt;/p&gt;

&lt;p&gt;// 如果你的箭头函数只爆款一个参数，
//  此时，你可以不使用小括号去包裹参数
let languages_lower = languages.map(language =&amp;gt; language.toLowerCase());&lt;/p&gt;

&lt;p&gt;// 如果你的函数接收多个参数，你必须使用小括号包裹住它们
let languages_lower = languages.map((language, unused_param) =&amp;gt; language.toLowerCase());&lt;/p&gt;

&lt;p&gt;console.log(languages_lower); // [“spanish”, “french”, “italian”, “german”, “polish”]&lt;/p&gt;

&lt;p&gt;// 最后，如果你的函数不接收参数，你也必须使用一个空括号
(() =&amp;gt; alert(“Hello!”))();&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;更详细单内容，我推荐你参考&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;MDN的文档&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://scotch.io/tutorials/better-node-with-es6-pt-i&quot;&gt;Better Node with ES6, Pt. I&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS/blob/master/this%20&amp;amp;%20object%20prototypes/ch2.md&quot;&gt;this All Makes Sense Now!&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sun, 01 May 2016 00:00:00 +0800</pubDate>
        <link>twolun.github.com/posts/quirks-of-dynamic-this.html</link>
        <guid isPermaLink="true">twolun.github.com/posts/quirks-of-dynamic-this.html</guid>
        
        
        <category>technique</category>
        
      </item>
    
      <item>
        <title>JavaScript面向对象编程实践</title>
        <description>&lt;p&gt;写本文的初衷是基于不久前写的一篇&lt;a href=&quot;http://wwsun.github.io/posts/javascript-oo-summary.html&quot;&gt;JavaScript面向对象深入解读&lt;/a&gt;这篇博文，
因此在此基础上谈一谈如何具体的使用面向对象的方式进行前端开发。随着认识的深入，将会形成一个系列，综述前端开发方式这些年来的变化。
本文通过面向对象的方式来解释组件开发的过程，我们将会以选项卡组件开发为例。向你介绍如何从零开始使用面向对象的方式开发前端组件。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;本文项目的源代码存放在&lt;a href=&quot;https://github.com/wwsun/component-tab&quot;&gt;Github仓库&lt;/a&gt;中。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;从0到1&lt;/h2&gt;

&lt;p&gt;假设我们想创建一个Tab多选项卡组件，用于切换选择不同的内容。&lt;/p&gt;

&lt;p&gt;初始的HTML结构如下：&lt;/p&gt;

&lt;p&gt;```html&lt;/p&gt;
&lt;div class=&quot;tab&quot;&gt;
    &lt;ul class=&quot;tab-menuWrapper&quot;&gt;
        &lt;li class=&quot;tab-menu&quot;&gt;menu1&lt;/li&gt;
        &lt;li class=&quot;tab-menu&quot;&gt;menu2&lt;/li&gt;
        &lt;li class=&quot;tab-menu&quot;&gt;menu3&lt;/li&gt;
        &lt;li class=&quot;tab-menu&quot;&gt;menu4&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;tab-contentWrapper&quot;&gt;
        &lt;div class=&quot;tab-content&quot;&gt;content1&lt;/div&gt;
        &lt;div class=&quot;tab-content&quot; style=&quot;display: none;&quot;&gt;content2&lt;/div&gt;
        &lt;div class=&quot;tab-content&quot; style=&quot;display: none;&quot;&gt;content3&lt;/div&gt;
        &lt;div class=&quot;tab-content&quot; style=&quot;display: none;&quot;&gt;content4&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;初始的样式代码如下：&lt;/p&gt;

&lt;p&gt;```css
ul {
    padding: 0;
    margin: 0;
}&lt;/p&gt;

&lt;p&gt;.tab {
    width: 400px;
}&lt;/p&gt;

&lt;p&gt;.tab-menuWrapper {
    padding-left: 20px;
}&lt;/p&gt;

&lt;p&gt;.tab-menuWrapper li {
    float: left;
    display: inline;
    padding: 5px;
    border: 1px solid #333;
    border-bottom: none;
    margin-right: 5px;
    cursor: pointer;
}&lt;/p&gt;

&lt;p&gt;.tab-contentWrapper {
    border: 1px solid #333;
    clear: left;
    padding: 5px;
}
```&lt;/p&gt;

&lt;p&gt;我们需要使用面向对象的方式来实现Tab组件的展示和交互逻辑。&lt;/p&gt;

&lt;p&gt;利用构造函数，我们编写&lt;code class=&quot;highlighter-rouge&quot;&gt;Tab&lt;/code&gt;构造函数：&lt;/p&gt;

&lt;p&gt;```javascript
function Tab(config) {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;this._root = config.root;
var trigger = config.trigger || &#39;click&#39;;

this._tabMenus = this._root.getElementsByClassName(&#39;tab-menu&#39;);
this._tabContents = this._root.getElementsByClassName(&#39;tab-content&#39;);

var self = this;

var i,
    n;
for (i = 0, n = this._tabMenus.length; i &amp;lt; n; i++) {
    this._tabMenus[i]._index = i;
    setEvent(this._tabMenus[i], trigger, function () {
        self.showItem(this._index);
    });
} } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中&lt;code class=&quot;highlighter-rouge&quot;&gt;showItem(n)&lt;/code&gt;方法用于显示目标文本框。实现如下&lt;/p&gt;

&lt;p&gt;```javascript
Tab.prototype.showItem = function (n) {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var i;
for (i = 0; i &amp;lt; this._tabContents.length; i++) {
    this._tabContents[i].style.display = &#39;none&#39;;
}
this._tabContents[n].style.display = &#39;block&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;};
```&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setEvent&lt;/code&gt;方法用于事件绑定：&lt;/p&gt;

&lt;p&gt;```javascript
var setEvent = function (node, eventType, handler, scope) {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;node = typeof node === &#39;string&#39; ? document.getElementById(node) : node;
scope = scope || node;

node.addEventListener(eventType, function () {
    handler.apply(scope, arguments);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;};
```&lt;/p&gt;

&lt;p&gt;最后让Tab组件工作：&lt;/p&gt;

&lt;p&gt;```javascript
var tabs = document.getElementsByClassName(‘tab’);&lt;/p&gt;

&lt;p&gt;new Tab({
    root: tabs[0]
});
```&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;完善&lt;/h2&gt;

&lt;p&gt;我们想要高亮当前到选项卡。&lt;/p&gt;

&lt;p&gt;我们首先增加一个&lt;code class=&quot;highlighter-rouge&quot;&gt;.ative&lt;/code&gt;样式，用于修改激活选项卡的样式。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;css
.active {
    color: white;
    background: green;
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;完善Tab组件：&lt;/p&gt;

&lt;p&gt;```javascript
Tab.prototype.showItem = function (n) {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var i;
for (i = 0; i &amp;lt; this._tabContents.length; i++) {
    this._tabContents[i].style.display = &#39;none&#39;;
}
this._tabContents[n].style.display = &#39;block&#39;;

if (this._currentClass) {
    var currentMenu = this._root.getElementsByClassName(this._currentClass)[0];
    if (currentMenu) {
        removeClass(currentMenu, this._currentClass);
    }
    addClass(this._tabMenus[n], this._currentClass);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;};
```&lt;/p&gt;

&lt;p&gt;我们增加了&lt;code class=&quot;highlighter-rouge&quot;&gt;removeClass&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;addClass&lt;/code&gt;两个辅助方法，分别用于给指定的dom节点删除和增加样式。&lt;/p&gt;

&lt;p&gt;使用方法上，我们增加了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;currentClass&lt;/code&gt;来供用户自定义激活选项卡的样式。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
new Tab({
    root: tabs[1],
    currentClass: &#39;active&#39;
});
&lt;/code&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 10 Apr 2016 00:00:00 +0800</pubDate>
        <link>twolun.github.com/posts/javascript-oo-tutorial.html</link>
        <guid isPermaLink="true">twolun.github.com/posts/javascript-oo-tutorial.html</guid>
        
        
        <category>technique</category>
        
      </item>
    
      <item>
        <title>使用Mocha和Chai来测试Node.js应用</title>
        <description>&lt;p&gt;随着应用程序规模的越加复杂化，要确保代码的稳定性越来越困难。测试是可重复的代码片段，
可以对应用程序以期望的方式进行工作做出断言，从而保证代码质量。对于Node.js开发而言，
开发人员要极其关注其代码的测试环节，因此本文将会详细的介绍Node.js程序的测试方案，
介绍如何使用Mcha和Chai来测试你的Node,js应用。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;section&quot;&gt;测试&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;从零开始&lt;/h3&gt;

&lt;p&gt;我们需要为我们编写的程序提供测试。例如，测试可以是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;某个HTTP响应是否返回200代码？&lt;/li&gt;
  &lt;li&gt;某个方法是否返回特定的值？&lt;/li&gt;
  &lt;li&gt;某个方法是否返回一个字符串？某个方法是否接收两个参数、执行计算然后返回正确的数？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过测试，当开发者对代码做出修改之后，可以确认不会给应用程序引入新的bug或错误。此外，
有些开发人员也使用测试来驱动应用程序的创建，这个过程称之为测试驱动开发（TDD），
可以参考我&lt;a href=&quot;http://wwsun.github.io/posts/tdd.html&quot;&gt;之前写过的一篇博文&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;tdd-vs-bdd&quot;&gt;TDD vs BDD&lt;/h3&gt;

&lt;p&gt;上面我们大致了解了测试驱动开发TDD。此外，许多开发人员还喜欢使用行为驱动的开发（BDD）。
BDD从外部考虑应用程序，而不是从内部测试程序的工作情况。例如：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;例1：当用户注册时，应用程序应当接收POST请求，检查字段是否有效，然后将数据库中的用户数量递增1。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;上面这个例子更接近于TDD，开发人员以应用程序应该有的功能为出发点为应用程序代码编写测试。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;例2：作为一个用户，当我成功注册时，我应该看到“感谢注册”。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;例2描述用户如何与应用程序交互以及他们期望看到的是什么。目前，Node.js社区的趋势是使用BDD，而不是TDD。
BDD更容易让相关人员介入到测试中。在BDD中，测试是以应用程序与来自外界的交互为基础，而不需要理解应用程序的内部原理。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;编写可测试代码&lt;/h3&gt;

&lt;p&gt;编写可测试代码的几个原则：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;单一职责：让你的代码逻辑尽可能的单一，分离不同的功能，这样可以让代码更容易被测试&lt;/li&gt;
  &lt;li&gt;接口抽象：目标是针对接口进行测试，而具体代码实现的变化不影响为接口编写的单元测试&lt;/li&gt;
  &lt;li&gt;层次分离：代码分层，可以进行逐层测试&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;单元测试&lt;/h3&gt;

&lt;p&gt;单元测试主要包括断言、测试框架、测试用例、测试覆盖率、Mock、持续集成几个方面，对于Node而言，
还要加入异步代码测试和私有方法测试这两个部分。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;断言&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;断言就是单元测试中用来保证最小单元是否正常的检测方法。Node中有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt;模块，
它是一个简单的测试框架，提供了一组断言方法，让开发人员得以为Node.js应用创建低级测试，
并且很多的主要模块都调用了这个模块，感兴趣的话，可以具体看一下它的&lt;a href=&quot;https://nodejs.org/api/assert.html&quot;&gt;api文档&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;断言通常用于检查程序在运行时是否满足某个期望。一个简单的例子如下：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
var assert = require(&#39;assert&#39;);
assert.equal(Math.max(1, 100), 100);
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果期望不能满足，会抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;AssertionError&lt;/code&gt;异常，整个程序将会停止执行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;题外话：JavaScript中比较相等&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;==&lt;/code&gt;运算符&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
&quot;8&quot; == 8 // true
&#39;&#39; == &#39;0&#39; // false
0 == `` // true
&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;===&lt;/code&gt;运算符：它检查值是否是相同的值，以及是否是相同的类型&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
&quot;8&quot; === 8 // false
&#39;&#39; === &#39;0&#39; // false
0 === &#39;&#39; // false
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;测试框架&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;测试框架用于为测试服务，本身并不参与测试，主要用于管理测试用例和测试报告，提升测试用例的开发速度、可维护性和可读性。
后面我们会介绍Node中最常用的测试框架&lt;a href=&quot;http://mochajs.org/&quot;&gt;Mocha&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;有关Node中单元测试的更多内容，可以参考朴灵的《&lt;a href=&quot;http://www.ituring.com.cn/book/1290&quot;&gt;深入浅出Node.js&lt;/a&gt;》的第10章，
该书给出了较为完整的介绍。下面我们进入实践单元，来具体的介绍如何进行Node程序代码的单元测试。&lt;/p&gt;

&lt;h2 id=&quot;moach&quot;&gt;Moach&lt;/h2&gt;

&lt;p&gt;Mocha 是一个JavaScript的测试框架，而chai是一个断言库，两者搭配使用更佳。
Mocha允许开发者使用模块化方法测试Node.js应用程序，Mocha非常的简单易学，
在Node和浏览器都可运行。Mocha的功能非常丰富，能够让异步测试变得简单有趣。
Mocha在运行测试用例过程中，当捕获到错误时，依旧能够灵活地运行精确的报告。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;示例程序&lt;/h3&gt;

&lt;p&gt;访问&lt;a href=&quot;http://mochajs.org/&quot;&gt;Mocha&lt;/a&gt;的官网，有一个简单的tutorial，我们可以跟着流程走一遍。&lt;/p&gt;

&lt;p&gt;在node项目中进行安装：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install mocha --save-dev  // npm install mocha -g
npm install chai
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;官方的示例程序大致如下：&lt;/p&gt;

&lt;p&gt;```javascript
// test.js&lt;/p&gt;

&lt;p&gt;var assert = require(‘assert’);
describe(‘Array’, function() {
  describe(‘#indexOf()’, function () {
    it(‘should return -1 when the value is not present’, function () {
      assert.equal(-1, [1,2,3].indexOf(5));
      assert.equal(-1, [1,2,3].indexOf(0));
    });
  });
});
```&lt;/p&gt;

&lt;p&gt;然后，在&lt;code class=&quot;highlighter-rouge&quot;&gt;package.json&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;scripts&lt;/code&gt;属性中加入&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;test&quot;: &quot;mocha test.js&quot;&lt;/code&gt;。
如果你全局安装了Mocha，只需要在命令行中定位到测试文件下运行&lt;code class=&quot;highlighter-rouge&quot;&gt;mocha&lt;/code&gt;命令即可。
或者，我们建议使用&lt;code class=&quot;highlighter-rouge&quot;&gt;npm run test&lt;/code&gt;命令来执行测试。&lt;/p&gt;

&lt;p&gt;下面来介绍，上面所写的单元测试中所涉及到的几个关键方法：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;describe(moduleName, callback)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;描述一句测试用例是否正确。首先&lt;code class=&quot;highlighter-rouge&quot;&gt;describe&lt;/code&gt;是可以嵌套的，多个&lt;code class=&quot;highlighter-rouge&quot;&gt;describe&lt;/code&gt;嵌套的使用用于描述模块下的子模块的关系，
上面的代码的意思就是测试&lt;code class=&quot;highlighter-rouge&quot;&gt;Array&lt;/code&gt;这个类下面的&lt;code class=&quot;highlighter-rouge&quot;&gt;#indexOf()&lt;/code&gt;方法, &lt;code class=&quot;highlighter-rouge&quot;&gt;moduleName&lt;/code&gt;是可以随便定义的，即是是中文也可以。 
&lt;code class=&quot;highlighter-rouge&quot;&gt;“#”&lt;/code&gt;的使用也是一般约定，不喜欢你也会换个或不用也可以。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;it(info, callback)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;真正的测试语句是在&lt;code class=&quot;highlighter-rouge&quot;&gt;it&lt;/code&gt;函数的回调里面，&lt;code class=&quot;highlighter-rouge&quot;&gt;info&lt;/code&gt;也是一句描述性的说明，看得懂就行。
&lt;code class=&quot;highlighter-rouge&quot;&gt;callback&lt;/code&gt;里面的断言决定这条测试是否正确。如果失败的话控制台会把log打印出来。
一个&lt;code class=&quot;highlighter-rouge&quot;&gt;it&lt;/code&gt;对应一个测试用例，里面可以有多条断言或一条断言。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;assert.equal（exp1,exp2）&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;mocha的断言语句，&lt;code class=&quot;highlighter-rouge&quot;&gt;exp1&lt;/code&gt;是否等于&lt;code class=&quot;highlighter-rouge&quot;&gt;exp2&lt;/code&gt;. 其他更多用法可以查考mocha的文档，但是这里一般我们使用&lt;code class=&quot;highlighter-rouge&quot;&gt;chai&lt;/code&gt;来作为断言库。
更加友好的实现我们的断言方式。&lt;/p&gt;

&lt;p&gt;Mocha鼓励用户使用简单直白的英语以BDD风格来描述应用程序。例如：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
describe(&#39;Comparing strings&#39;, function () { } );
describe(&#39;when comparing different strings&#39;, function() { } );
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;异步代码测试&lt;/h3&gt;

&lt;p&gt;上面的代码是同步代码，非常的简单。我们来看看异步代码的测试，对于Mocha而言也很简单。
只需要在测试完成的时候调用回调即可。看下面的代码：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
describe(&#39;User&#39;, function() {
  describe(&#39;#save()&#39;, function() {
    it(&#39;should save without error&#39;, function(done) {
      var user = new User(&#39;Luna&#39;);
      user.save(function(err) {
        if (err) throw err;
        done(); // 通过使用 done() 回调的方法来表示测试完成
      });
    });
  });
});
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;其中&lt;code class=&quot;highlighter-rouge&quot;&gt;user.save()&lt;/code&gt;是一个需要连接数据库的异步操作。和前面代码不同的是，这里使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;done&lt;/code&gt;作为回调函数（通常都这么命名），
作为约定，Mocha会等到其执行完毕。为了简化问题，回调函数&lt;code class=&quot;highlighter-rouge&quot;&gt;done()&lt;/code&gt;能够接收错误，因此代码可以简化为：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
it(&#39;should save without error&#39;, function(done) {
  var user = new User(&#39;Luna&#39;);
  user.save(done);
});
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;promise&quot;&gt;使用Promise&lt;/h3&gt;

&lt;p&gt;当然，如果不想使用回调的话，你也可以返回&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise&lt;/a&gt;，
示例如下：&lt;/p&gt;

&lt;p&gt;```javascript
// 在每次单元测试前执行
beforeEach(function() {
  return db.clear()
    .then(function() {
      return db.save([tobi, loki, jane]);
    });
});&lt;/p&gt;

&lt;p&gt;describe(‘#find()’, function() {
  it(‘respond with matching records’, function() {
    return db.find({ type: ‘User’ }).should.eventually.have.length(3);
  });
});
```&lt;/p&gt;

&lt;p&gt;你可以参考&lt;a href=&quot;https://www.npmjs.com/package/chai-as-promised&quot;&gt;chai-as-promised&lt;/a&gt;这个库。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;钩子&lt;/h3&gt;

&lt;p&gt;Mocha提供的钩子包括&lt;code class=&quot;highlighter-rouge&quot;&gt;before()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;after()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;beforeEach()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;afterEach()&lt;/code&gt;，可以用于测试的预处理和后处理等通过。&lt;/p&gt;

&lt;p&gt;```javascript
describe(‘hooks’, function() {&lt;/p&gt;

&lt;p&gt;before(function() {
    // runs before all tests in this block
  });&lt;/p&gt;

&lt;p&gt;after(function() {
    // runs after all tests in this block
  });&lt;/p&gt;

&lt;p&gt;beforeEach(function() {
    // runs before each test in this block
  });&lt;/p&gt;

&lt;p&gt;afterEach(function() {
    // runs after each test in this block
  });&lt;/p&gt;

&lt;p&gt;// test cases
});
```&lt;/p&gt;

&lt;p&gt;当然，对于钩子，你可以提供描述信息，只需要提供一个参数即可（或者使用命名的函数作为回调）：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
beforeEach(&#39;some description&#39;, function() {
  // beforeEach:some description
});
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;pending-tests&quot;&gt;待处理的测试（pending tests）&lt;/h3&gt;

&lt;p&gt;就是it里面的function留空。mocha默认会pass这条测试。这样的用法其实相当于，某项目负责人定义好了要测试什么内容，
之后由相应的开发去实现具体。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
describe(&#39;Array&#39;, function() {
  describe(&#39;#indexOf()&#39;, function() {
    // pending test below
    it(&#39;should return -1 when the value is not present&#39;);
  });
});
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;有关Mocha的其他特性可以参考Mocha的官方网站提供的示例，都非常的简单，强烈建议阅读作为入门。&lt;/p&gt;

&lt;h2 id=&quot;chai&quot;&gt;Chai&lt;/h2&gt;

&lt;p&gt;Chai是一个BDD/TDD模式的断言库，也可以同时运行在node和浏览器环境，能够高效的和绝大多数JavaScript测试框架搭配使用。
BDD，行为驱动开发（注重测试逻辑），TDD是测试驱动开发（注重输出结果）。下面的例子主要使用的BDD。&lt;/p&gt;

&lt;p&gt;关于Chai，我推荐你也从&lt;a href=&quot;http://chaijs.com/guide/styles/&quot;&gt;官方示例&lt;/a&gt;入手。有关Chai，我们主要关注的是BDD的测试代码风格。
看一个例子：&lt;/p&gt;

&lt;p&gt;```javascript
// BDD: should
var should = require(‘chai’).should() //actually call the function
  , foo = ‘bar’
  , beverages = { tea: [ ‘chai’, ‘matcha’, ‘oolong’ ] };&lt;/p&gt;

&lt;p&gt;foo.should.be.a(‘string’);
foo.should.equal(‘bar’);
foo.should.have.length(3);
beverages.should.have.property(‘tea’).with.length(3);&lt;/p&gt;

&lt;p&gt;// BDD: expect 推荐使用
var expect = require(‘chai’).expect
  , foo = ‘bar’
  , beverages = { tea: [ ‘chai’, ‘matcha’, ‘oolong’ ] };&lt;/p&gt;

&lt;p&gt;expect(foo).to.be.a(‘string’);
expect(foo).to.equal(‘bar’);
expect(foo).to.have.length(3);
expect(beverages).to.have.property(‘tea’).with.length(3);
```&lt;/p&gt;

&lt;p&gt;BDD风格主要包括两个方法，分别是&lt;code class=&quot;highlighter-rouge&quot;&gt;expect&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;should&lt;/code&gt;。都可以通过链接的方式构造断言，但主要区分在于断言的初始构造。
&lt;code class=&quot;highlighter-rouge&quot;&gt;should&lt;/code&gt;的风格非常接近于自然语言。我们可以使用Chai的&lt;code class=&quot;highlighter-rouge&quot;&gt;should&lt;/code&gt;替代&lt;code class=&quot;highlighter-rouge&quot;&gt;Mocha&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;assert&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;两者的区别是什么？&lt;code class=&quot;highlighter-rouge&quot;&gt;expect&lt;/code&gt;需要的只是对象的引用，而&lt;code class=&quot;highlighter-rouge&quot;&gt;should&lt;/code&gt;需要函数先执行。
&lt;code class=&quot;highlighter-rouge&quot;&gt;expect&lt;/code&gt;接口提供的函数可以作为链接断言的起点，并且适用于Node和所有的浏览器环境，
而&lt;code class=&quot;highlighter-rouge&quot;&gt;should&lt;/code&gt;接口继承自&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.prototype&lt;/code&gt;，提供的仅仅是一个getter作为链接断言的起点，并且不能再IE浏览器上工作。&lt;/p&gt;

&lt;p&gt;更多内容，还是推荐你阅读Chai的官方文档和&lt;a href=&quot;http://chaijs.com/api/bdd/&quot;&gt;BDD的API&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;http://segmentfault.com/a/1190000003949229&lt;/li&gt;
  &lt;li&gt;http://mherman.org/blog/2015/09/10/testing-node-js-with-mocha-and-chai&lt;/li&gt;
  &lt;li&gt;http://www.alloyteam.com/2013/12/hour-class-learning-costs-javascript-unit-testing-tool-matcha-mocha-and-chai&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 24 Mar 2016 00:00:00 +0800</pubDate>
        <link>twolun.github.com/posts/testing-node.js-with-mocha-and-chai.html</link>
        <guid isPermaLink="true">twolun.github.com/posts/testing-node.js-with-mocha-and-chai.html</guid>
        
        
        <category>technique</category>
        
      </item>
    
      <item>
        <title>深入解读JavaScript面向对象编程实践</title>
        <description>&lt;p&gt;面向对象编程是用抽象方式创建基于现实世界模型的一种编程模式，主要包括模块化、多态、和封装几种技术。
对JavaScript而言，其核心是支持面向对象的，同时它也提供了强大灵活的基于原型的面向对象编程能力。
本文将会深入的探讨有关使用JavaScript进行面向对象编程的一些核心基础知识，包括对象的创建，继承机制，
最后还会简要的介绍如何借助ES6提供的新的类机制重写传统的JavaScript面向对象代码。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;section&quot;&gt;面向对象的几个概念&lt;/h2&gt;

&lt;p&gt;在进入正题前，先了解传统的面向对象编程（例如Java）中常会涉及到的概念，大致可以包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;类：定义对象的特征。它是对象的属性和方法的模板定义。&lt;/li&gt;
  &lt;li&gt;对象（或称实例）：类的一个实例。&lt;/li&gt;
  &lt;li&gt;属性：对象的特征，比如颜色、尺寸等。&lt;/li&gt;
  &lt;li&gt;方法：对象的行为，比如行走、说话等。&lt;/li&gt;
  &lt;li&gt;构造函数：对象初始化的瞬间被调用的方法。&lt;/li&gt;
  &lt;li&gt;继承：子类可以继承父类的特征。例如，猫继承了动物的一般特性。&lt;/li&gt;
  &lt;li&gt;封装：一种把数据和相关的方法绑定在一起使用的方法。&lt;/li&gt;
  &lt;li&gt;抽象：结合复杂的继承、方法、属性的对象能够模拟现实的模型。&lt;/li&gt;
  &lt;li&gt;多态：不同的类可以定义相同的方法或属性。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在JavaScript的面向对象编程中大体也包括这些。不过在称呼上可能稍有不同，例如，JavaScript中没有原生的“类”的概念，
而只有&lt;strong&gt;对象&lt;/strong&gt;的概念。因此，随着你认识的深入，我们会混用对象、实例、构造函数等概念。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;对象（类）的创建&lt;/h2&gt;

&lt;p&gt;在JavaScript中，我们通常可以使用构造函数来创建特定类型的对象。诸如Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中。
此外，我们也可以创建自定义的构造函数。例如：&lt;/p&gt;

&lt;p&gt;```javascript
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
}&lt;/p&gt;

&lt;p&gt;var person1 = new Person(‘Weiwei’, 27, ‘Student’);
var person2 = new Person(‘Lily’, 25, ‘Doctor’);
```&lt;/p&gt;

&lt;p&gt;按照惯例，构造函数始终都应该以一个大写字母开头（和Java中定义的类一样），普通函数则小写字母开头。
要创建&lt;code class=&quot;highlighter-rouge&quot;&gt;Person&lt;/code&gt;的新实例，必须使用&lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt;操作符。以这种方式调用构造函数实际上会经历以下4个步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建一个新对象（实例）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;将构造函数的作用域赋给新对象&lt;/strong&gt;（也就是重设了&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;的指向，&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;就指向了这个新对象）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;执行构造函数中的代码&lt;/strong&gt;（为这个新对象添加属性）&lt;/li&gt;
  &lt;li&gt;返回新对象&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;有关&lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt;操作符的更多内容请参考&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new&quot;&gt;这篇文档&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;在上面的例子中，我们创建了&lt;code class=&quot;highlighter-rouge&quot;&gt;Person&lt;/code&gt;的两个实例&lt;code class=&quot;highlighter-rouge&quot;&gt;person1&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;person2&lt;/code&gt;。
这两个对象默认都有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;constructor&lt;/code&gt;属性，该属性指向它们的构造函数&lt;code class=&quot;highlighter-rouge&quot;&gt;Person&lt;/code&gt;，也就是说：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
console.log(person1.constructor == Person);  //true
console.log(person2.constructor == Person);  //true
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;自定义对象的类型检测&lt;/h3&gt;

&lt;p&gt;我们可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;instanceof&lt;/code&gt;操作符进行类型检测。我们创建的所有对象既是&lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt;的实例，同时也是&lt;code class=&quot;highlighter-rouge&quot;&gt;Person&lt;/code&gt;的实例。
因为所有的对象都继承自&lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
console.log(person1 instanceof Object);  //true
console.log(person1 instanceof Person);  //true
console.log(person2 instanceof Object);  //true
console.log(person2 instanceof Person);  //true
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;构造函数的问题&lt;/h3&gt;

&lt;p&gt;我们&lt;strong&gt;不建议在构造函数中直接定义方法&lt;/strong&gt;，如果这样做的话，每个方法都要在每个实例上重新创建一遍，这将非常损耗性能。
——不要忘了，ECMAScript中的&lt;strong&gt;函数是对象&lt;/strong&gt;，每定义一个函数，也就实例化了一个对象。&lt;/p&gt;

&lt;p&gt;幸运的是，在ECMAScript中，我们可以借助&lt;strong&gt;原型对象&lt;/strong&gt;来解决这个问题。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;借助原型模式定义对象的方法&lt;/h3&gt;

&lt;p&gt;我们创建的每个函数都有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;prototype&lt;/code&gt;属性，这个属性是一个指针，指向该函数的&lt;strong&gt;原型对象&lt;/strong&gt;，
该对象包含了由特定类型的&lt;strong&gt;所有实例共享的属性和方法&lt;/strong&gt;。也就是说，我们可以利用原型对象来让所有对象实例共享它所包含的属性和方法。&lt;/p&gt;

&lt;p&gt;```javascript
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
}&lt;/p&gt;

&lt;p&gt;// 通过原型模式来添加所有实例共享的方法
// sayName() 方法将会被Person的所有实例共享，而避免了重复创建
Person.prototype.sayName = function () {
  console.log(this.name);
};&lt;/p&gt;

&lt;p&gt;var person1 = new Person(‘Weiwei’, 27, ‘Student’);
var person2 = new Person(‘Lily’, 25, ‘Doctor’);&lt;/p&gt;

&lt;p&gt;console.log(person1.sayName === person2.sayName); // true&lt;/p&gt;

&lt;p&gt;person1.sayName(); // Weiwei
person2.sayName(); // Lily
```&lt;/p&gt;

&lt;p&gt;正如上面的代码所示，通过原型模式定义的方法&lt;code class=&quot;highlighter-rouge&quot;&gt;sayName()&lt;/code&gt;为所有的实例所共享。也就是，
&lt;code class=&quot;highlighter-rouge&quot;&gt;person1&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;person2&lt;/code&gt;访问的是同一个&lt;code class=&quot;highlighter-rouge&quot;&gt;sayName()&lt;/code&gt;函数。同样的，公共属性也可以使用原型模式进行定义。例如：&lt;/p&gt;

&lt;p&gt;```javascript
function Chinese (name) {
    this.name = name;
}&lt;/p&gt;

&lt;p&gt;Chinese.prototype.country = ‘China’; // 公共属性，所有实例共享
```&lt;/p&gt;

&lt;p&gt;当我们&lt;code class=&quot;highlighter-rouge&quot;&gt;new Person()&lt;/code&gt;时，返回的&lt;code class=&quot;highlighter-rouge&quot;&gt;Person&lt;/code&gt;实例会结合构造函数中定义的属性、行为和原型中定义的属性、行为，
生成最终属于&lt;code class=&quot;highlighter-rouge&quot;&gt;Person&lt;/code&gt;实例的属性和行为。&lt;/p&gt;

&lt;p&gt;构造函数中定义的属性和行为的优先级要比原型中定义的属性和行为的优先级高，如果构造函数和原型中定义了同名的属性或行为，
构造函数中的属性或行为会覆盖原型中的同名的属性或行为。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;原型对象&lt;/h3&gt;

&lt;p&gt;现在我们来深入的理解一下什么是原型对象。&lt;/p&gt;

&lt;p&gt;只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个&lt;code class=&quot;highlighter-rouge&quot;&gt;prototype&lt;/code&gt;属性，这个属性指向函数的原型对象。
在默认情况下，所有原型对象都会自动获得一个&lt;code class=&quot;highlighter-rouge&quot;&gt;constructor&lt;/code&gt;属性，这个属性包含一个指向&lt;code class=&quot;highlighter-rouge&quot;&gt;prototype&lt;/code&gt;属性所在函数的指针。
也就是说：&lt;code class=&quot;highlighter-rouge&quot;&gt;Person.prototype.constructor&lt;/code&gt;指向&lt;code class=&quot;highlighter-rouge&quot;&gt;Person&lt;/code&gt;构造函数。&lt;/p&gt;

&lt;p&gt;创建了自定义的构造函数之后，其原型对象默认只会取得&lt;code class=&quot;highlighter-rouge&quot;&gt;constructor&lt;/code&gt;属性；至于其他方法，则都是从&lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt;继承而来的。
当调用构造函数创建一个新实例后，该实例内部将包含一个指针（内部属性），指向构造函数的原型对象。ES5中称这个指针为&lt;code class=&quot;highlighter-rouge&quot;&gt;[[Prototype]]&lt;/code&gt;，
在Firefox、Safari和Chrome在每个对象上都支持一个属性&lt;code class=&quot;highlighter-rouge&quot;&gt;__proto__&lt;/code&gt;（目前已被废弃）；而在其他实现中，这个属性对脚本则是完全不可见的。
要注意，&lt;strong&gt;这个链接存在于实例与构造函数的原型对象之间，而不是实例与构造函数之间&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;这三者关系的示意图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpv9g.com1.z0.glb.clouddn.com/imgprototype-graph-1.jpg&quot; alt=&quot;prototype graph&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图展示了&lt;code class=&quot;highlighter-rouge&quot;&gt;Person&lt;/code&gt;构造函数、&lt;code class=&quot;highlighter-rouge&quot;&gt;Person&lt;/code&gt;的原型对象以及&lt;code class=&quot;highlighter-rouge&quot;&gt;Person&lt;/code&gt;现有的两个实例之间的关系。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Person.prototype&lt;/code&gt;指向了原型对象&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Person.prototype.constructor&lt;/code&gt;又指回了&lt;code class=&quot;highlighter-rouge&quot;&gt;Person&lt;/code&gt;构造函数&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Person&lt;/code&gt;的每个实例&lt;code class=&quot;highlighter-rouge&quot;&gt;person1&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;person2&lt;/code&gt;都包含一个内部属性（通常为&lt;code class=&quot;highlighter-rouge&quot;&gt;__proto__&lt;/code&gt;），&lt;code class=&quot;highlighter-rouge&quot;&gt;person1.__proto__&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;person2.__proto__&lt;/code&gt;指向了原型对象&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-6&quot;&gt;查找对象属性&lt;/h3&gt;

&lt;p&gt;从上图我们发现，虽然&lt;code class=&quot;highlighter-rouge&quot;&gt;Person&lt;/code&gt;的两个实例都不包含属性和方法，但我们却可以调用&lt;code class=&quot;highlighter-rouge&quot;&gt;person1.sayName()&lt;/code&gt;。
这是通过查找对象属性的过程来实现的。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;搜索首先从&lt;strong&gt;对象实例&lt;/strong&gt;本身开始（实例&lt;code class=&quot;highlighter-rouge&quot;&gt;person1&lt;/code&gt;有&lt;code class=&quot;highlighter-rouge&quot;&gt;sayName&lt;/code&gt;属性吗？——没有）&lt;/li&gt;
  &lt;li&gt;如果没找到，则继续搜索指针指向的&lt;strong&gt;原型对象&lt;/strong&gt;（&lt;code class=&quot;highlighter-rouge&quot;&gt;person1.__proto__&lt;/code&gt;有&lt;code class=&quot;highlighter-rouge&quot;&gt;sayName&lt;/code&gt;属性吗？——有）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这也是多个对象实例共享原型所保存的属性和方法的基本原理。&lt;/p&gt;

&lt;p&gt;注意，如果我们在对象的实例中重写了某个原型中已存在的属性，则该实例属性会屏蔽原型中的那个属性。
此时，可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;delete&lt;/code&gt;操作符删除实例上的属性。&lt;/p&gt;

&lt;h3 id=&quot;objectgetprototypeof&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.getPrototypeOf()&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;根据ECMAScript标准，&lt;code class=&quot;highlighter-rouge&quot;&gt;someObject.[[Prototype]]&lt;/code&gt; 符号是用于指派 &lt;code class=&quot;highlighter-rouge&quot;&gt;someObject&lt;/code&gt; 的原型。
这个等同于 JavaScript 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;__proto__&lt;/code&gt; 属性（现已弃用，因为它不是标准）。
从ECMAScript 5开始, &lt;code class=&quot;highlighter-rouge&quot;&gt;[[Prototype]]&lt;/code&gt; 可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.getPrototypeOf()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.setPrototypeOf()&lt;/code&gt;访问器来访问。&lt;/p&gt;

&lt;p&gt;其中&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.getPrototypeOf()&lt;/code&gt;在所有支持的实现中，这个方法返回&lt;code class=&quot;highlighter-rouge&quot;&gt;[[Prototype]]&lt;/code&gt;的值。例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;person1.__proto__ === Object.getPrototypeOf(person1); // true
Object.getPrototypeOf(person1) === Person.prototype; // true
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;也就是说，&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.getPrototypeOf(p1)&lt;/code&gt;返回的对象实际就是这个对象的原型。
这个方法的兼容性请参考&lt;a href=&quot;http://caniuse.com/#search=getPrototypeOf()&quot;&gt;该链接&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;objectkeys&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.keys()&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;要取得对象上所有可枚举的实例属性，可以使用ES5中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.keys()&lt;/code&gt;方法。例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Object.keys(p1); // [&quot;name&quot;, &quot;age&quot;, &quot;job&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此外，如果你想要得到所有实例属性，无论它是否可枚举，都可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.getOwnPropertyName()&lt;/code&gt;方法。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;更简单的原型语法&lt;/h3&gt;

&lt;p&gt;在上面的代码中，如果我们要添加原型属性和方法，就要重复的敲一遍&lt;code class=&quot;highlighter-rouge&quot;&gt;Person.prototype&lt;/code&gt;。为了减少这个重复的过程，
更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象。
&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames&quot;&gt;参考资料&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;```javascript
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
}&lt;/p&gt;

&lt;p&gt;// 重写整个原型对象
Person.prototype = {&lt;/p&gt;

&lt;p&gt;// 这里务必要重新将构造函数指回Person构造函数，否则会指向这个新创建的对象
  constructor: Person, // Attention!&lt;/p&gt;

&lt;p&gt;sayName: function () {
    console.log(this.name);
  }
};&lt;/p&gt;

&lt;p&gt;var person1 = new Person(‘Weiwei’, 27, ‘Student’);
var person2 = new Person(‘Lily’, 25, ‘Doctor’);&lt;/p&gt;

&lt;p&gt;console.log(person1.sayName === person2.sayName); // true&lt;/p&gt;

&lt;p&gt;person1.sayName();  // Weiwei
person2.sayName();  // Lily
```&lt;/p&gt;

&lt;p&gt;在上面的代码中特意包含了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;constructor&lt;/code&gt;属性，并将它的值设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;Person&lt;/code&gt;，从而确保了通过该属性能够访问到适当的值。
注意，以这种方式重设&lt;code class=&quot;highlighter-rouge&quot;&gt;constructor&lt;/code&gt;属性会导致它的&lt;code class=&quot;highlighter-rouge&quot;&gt;[[Enumerable]]&lt;/code&gt;特性设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;。默认情况下，原生的&lt;code class=&quot;highlighter-rouge&quot;&gt;constructor&lt;/code&gt;属性是不可枚举的。
你可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.defineProperty()&lt;/code&gt;：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
// 重设构造函数，只适用于ES5兼容的浏览器
Object.defineProperty(Person.prototype, &quot;constructor&quot;, {
  enumerable: false,
  value: Person
});
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;组合使用构造函数模式和原型模式&lt;/h3&gt;

&lt;p&gt;创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，
而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方的引用，
最大限度的节省了内存。&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;继承&lt;/h2&gt;

&lt;p&gt;大多的面向对象语言都支持两种继承方式：接口继承和实现继承。ECMAScript只支持实现继承，而且其实现继承主要依靠原型链来实现。&lt;/p&gt;

&lt;p&gt;前面我们知道，JavaScript中实例的属性和行为是由构造函数和原型两部分共同组成的。如果我们想让&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;继承&lt;code class=&quot;highlighter-rouge&quot;&gt;Father&lt;/code&gt;，
那么我们就需要把&lt;code class=&quot;highlighter-rouge&quot;&gt;Father&lt;/code&gt;构造函数和原型中属性和行为全部传给&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;的构造函数和原型。&lt;/p&gt;

&lt;h3 id=&quot;section-10&quot;&gt;原型链继承&lt;/h3&gt;

&lt;p&gt;使用原型链作为实现继承的基本思想是：利用原型让一个引用类型继承另一个引用类型的属性和方法。首先我们先回顾一些基本概念：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;每个构造函数都有一个原型对象（&lt;code class=&quot;highlighter-rouge&quot;&gt;prototype&lt;/code&gt;）&lt;/li&gt;
  &lt;li&gt;原型对象包含一个指向构造函数的指针（&lt;code class=&quot;highlighter-rouge&quot;&gt;constructor&lt;/code&gt;）&lt;/li&gt;
  &lt;li&gt;实例都包含一个指向原型对象的内部指针（&lt;code class=&quot;highlighter-rouge&quot;&gt;[[Prototype]]&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果我们让原型对象等于另一个类型的实现，结果会怎么样？显然，&lt;strong&gt;此时的原型对象将包含一个指向另一个原型的指针&lt;/strong&gt;，
相应的，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，
如此层层递进，就构成了实例与原型的链条。
更详细的内容可以参考&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain&quot;&gt;这个链接&lt;/a&gt;。
先看一个简单的例子，它演示了使用原型链实现继承的基本框架：&lt;/p&gt;

&lt;p&gt;```javascript
function Father () {
  this.fatherValue = true;
}&lt;/p&gt;

&lt;p&gt;Father.prototype.getFatherValue = function () {
  console.log(this.fatherValue);
};&lt;/p&gt;

&lt;p&gt;function Child () {
  this.childValue = false;
}&lt;/p&gt;

&lt;p&gt;// 实现继承：继承自Father
Child.prototype = new Father();&lt;/p&gt;

&lt;p&gt;Child.prototype.getChildValue = function () {
  console.log(this.childValue);
};&lt;/p&gt;

&lt;p&gt;var instance = new Child();
instance.getFatherValue(); // true
instance.getChildValue();  // false
```&lt;/p&gt;

&lt;p&gt;在上面的代码中，原型链继承的核心语句是&lt;code class=&quot;highlighter-rouge&quot;&gt;Child.prototype = new Father()&lt;/code&gt;，它实现了&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;对&lt;code class=&quot;highlighter-rouge&quot;&gt;Father&lt;/code&gt;的继承，
而继承是通过创建&lt;code class=&quot;highlighter-rouge&quot;&gt;Father&lt;/code&gt;的实例，并将该实例赋给&lt;code class=&quot;highlighter-rouge&quot;&gt;Child.prototype&lt;/code&gt;实现的。&lt;/p&gt;

&lt;p&gt;实现的本质是重写原型对象，代之以一个新类型的实例。也就是说，原来存在于&lt;code class=&quot;highlighter-rouge&quot;&gt;Father&lt;/code&gt;的实例中的所有属性和方法，
现在也存在于&lt;code class=&quot;highlighter-rouge&quot;&gt;Child.prototype&lt;/code&gt;中了。&lt;/p&gt;

&lt;p&gt;这个例子中的实例以及构造函数和原型之间的关系如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpv9g.com1.z0.glb.clouddn.com/imgprototype-chain-inheritance.jpg&quot; alt=&quot;prototype chain inheritance&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在上面的代码中，我们没有使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;默认提供的原型，而是给它换了一个新原型；这个新原型就是&lt;code class=&quot;highlighter-rouge&quot;&gt;Father&lt;/code&gt;的实例。
于是，新原型不仅具有了作为一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Father&lt;/code&gt;的实例所拥有的全部属性和方法。而且其内部还有一个指针&lt;code class=&quot;highlighter-rouge&quot;&gt;[[Prototype]]&lt;/code&gt;，指向了&lt;code class=&quot;highlighter-rouge&quot;&gt;Father&lt;/code&gt;的原型。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;instance&lt;/code&gt;指向&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;的原型对象&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;的原型对象指向&lt;code class=&quot;highlighter-rouge&quot;&gt;Father&lt;/code&gt;的原型对象&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;getFatherValue()&lt;/code&gt;方法仍然还在&lt;code class=&quot;highlighter-rouge&quot;&gt;Father.prototype&lt;/code&gt;中&lt;/li&gt;
  &lt;li&gt;但是，&lt;code class=&quot;highlighter-rouge&quot;&gt;fatherValue&lt;/code&gt;则位于&lt;code class=&quot;highlighter-rouge&quot;&gt;Child.prototype&lt;/code&gt;中&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;instance.constructor&lt;/code&gt;现在指向的是&lt;code class=&quot;highlighter-rouge&quot;&gt;Father&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因为&lt;code class=&quot;highlighter-rouge&quot;&gt;fatherValue&lt;/code&gt;是一个实例属性，而&lt;code class=&quot;highlighter-rouge&quot;&gt;getFatherValue()&lt;/code&gt;则是一个原型方法。既然&lt;code class=&quot;highlighter-rouge&quot;&gt;Child.prototype&lt;/code&gt;现在是&lt;code class=&quot;highlighter-rouge&quot;&gt;Father&lt;/code&gt;的实例，
那么&lt;code class=&quot;highlighter-rouge&quot;&gt;fatherValue&lt;/code&gt;当然就位于该实例中。&lt;/p&gt;

&lt;p&gt;通过实现原型链，本质上扩展了本章前面介绍的原型搜索机制。例如，&lt;code class=&quot;highlighter-rouge&quot;&gt;instance.getFatherValue()&lt;/code&gt;会经历三个搜索步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;搜索实例&lt;/li&gt;
  &lt;li&gt;搜索&lt;code class=&quot;highlighter-rouge&quot;&gt;Child.prototype&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;搜索&lt;code class=&quot;highlighter-rouge&quot;&gt;Father.prototype&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;object&quot;&gt;别忘了&lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;所有的函数都默认原型都是&lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt;的实例，因此默认原型都会包含一个内部指针&lt;code class=&quot;highlighter-rouge&quot;&gt;[[Prototype]]&lt;/code&gt;，指向&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.prototype&lt;/code&gt;。
这也正是所有自定义类型都会继承&lt;code class=&quot;highlighter-rouge&quot;&gt;toString()&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;valueOf()&lt;/code&gt;等默认方法的根本原因。所以，
我们说上面例子展示的原型链中还应该包括另外一个继承层次。关于&lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt;的更多内容，可以参考&lt;a href=&quot;http://luopq.com/2016/02/28/Object-in-Javascript/&quot;&gt;这篇博客&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;也就是说，&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;继承了&lt;code class=&quot;highlighter-rouge&quot;&gt;Father&lt;/code&gt;，而&lt;code class=&quot;highlighter-rouge&quot;&gt;Father&lt;/code&gt;继承了&lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt;。当调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;instance.toString()&lt;/code&gt;时，
实际上调用的是保存在&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.prototype&lt;/code&gt;中的那个方法。&lt;/p&gt;

&lt;h3 id=&quot;section-11&quot;&gt;原型链继承的问题&lt;/h3&gt;

&lt;p&gt;首先是顺序，一定要先继承父类，然后为子类添加新方法。&lt;/p&gt;

&lt;p&gt;其次，&lt;strong&gt;使用原型链实现继承时，不能使用对象字面量创建原型方法&lt;/strong&gt;。因为这样做就会重写原型链，如下面的例子所示：&lt;/p&gt;

&lt;p&gt;```javascript
function Father () {
  this.fatherValue = true;
}&lt;/p&gt;

&lt;p&gt;Father.prototype.getFatherValue = function () {
  console.log(this.fatherValue);
};&lt;/p&gt;

&lt;p&gt;function Child () {
  this.childValue = false;
}&lt;/p&gt;

&lt;p&gt;// 继承了Father
// 此时的原型链为 Child -&amp;gt; Father -&amp;gt; Object
Child.prototype = new Father();&lt;/p&gt;

&lt;p&gt;// 使用字面量添加新方法，会导致上一行代码无效
// 此时我们设想的原型链被切断，而是变成 Child -&amp;gt; Object
// 所以我们不推荐这么写了
Child.prototype = {
  getChildValue: function () {
    console.log(this.childValue);
  }
};&lt;/p&gt;

&lt;p&gt;var instance = new Child();
instance.getChildValue();  // false
instance.getFatherValue(); // error!
```&lt;/p&gt;

&lt;p&gt;在上面的代码中，我们连续两次修改了&lt;code class=&quot;highlighter-rouge&quot;&gt;Child.prototype&lt;/code&gt;的值。由于现在的原型包含的是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt;的实例，
而非&lt;code class=&quot;highlighter-rouge&quot;&gt;Father&lt;/code&gt;的实例，因此我们设想中的原型链已经被切断——&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Father&lt;/code&gt;之间已经没有关系了。&lt;/p&gt;

&lt;p&gt;最后，在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，
给超类型的构造函数传递参数。因此，我们很少单独使用原型链。&lt;/p&gt;

&lt;h3 id=&quot;section-12&quot;&gt;借用构造函数继承&lt;/h3&gt;

&lt;p&gt;借用构造函数（constructor stealing）的基本思想如下：即在子类构造函数的内部调用超类型构造函数。&lt;/p&gt;

&lt;p&gt;```javascript
function Father (name) {
  this.name = name;
  this.colors = [‘red’, ‘blue’, ‘green’];
}&lt;/p&gt;

&lt;p&gt;function Child (name) {
  // 继承了Father，同时传递了参数
  // 之所以这么做，是为了获得Father构造函数中的所有属性和方法
  // 之所以用call，是为了修正Father内部this的指向
  Father.call(this, name);
}&lt;/p&gt;

&lt;p&gt;var instance1 = new Child(“weiwei”);
instance1.colors.push(‘black’);
console.log(instance1.colors); // [ ‘red’, ‘blue’, ‘green’, ‘black’ ]
console.log(instance1.name); // weiwei&lt;/p&gt;

&lt;p&gt;var instance2 = new Child(“lily”);
console.log(instance2.colors); // [ ‘red’, ‘blue’, ‘green’ ]
console.log(instance2.name); // lily
```&lt;/p&gt;

&lt;p&gt;为了确保&lt;code class=&quot;highlighter-rouge&quot;&gt;Father&lt;/code&gt;构造函数不会重写子类型的属性，可以在调用超类型构造函数后，再添加应该在子类型中定义的属性。&lt;/p&gt;

&lt;h3 id=&quot;section-13&quot;&gt;借用构造函数的缺点&lt;/h3&gt;

&lt;p&gt;同构造函数一样，无法实现方法的复用（所有的方法会被重复创建一份）。&lt;/p&gt;

&lt;h3 id=&quot;section-14&quot;&gt;组合使用原型链和借用构造函数&lt;/h3&gt;

&lt;p&gt;通常，我们会组合使用原型链继承和借用构造函数来实现继承。也就是说，使用原型链实现对原型属性和方法的继承，
而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。
我们改造最初的例子如下：&lt;/p&gt;

&lt;p&gt;```javascript
// 父类构造函数
function Person (name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
}&lt;/p&gt;

&lt;p&gt;// 父类方法
Person.prototype.sayName = function () {
  console.log(this.name);
};&lt;/p&gt;

&lt;p&gt;// ————–&lt;/p&gt;

&lt;p&gt;// 子类构造函数
function Student (name, age, job, school) {
  // 继承父类的所有实例属性（获得父类构造函数中的属性）
  Person.call(this, name, age, job);
  this.school = school; // 添加新的子类属性
}&lt;/p&gt;

&lt;p&gt;// 继承父类的原型方法（获得父类原型链上的属性和方法）
Student.prototype = new Person();&lt;/p&gt;

&lt;p&gt;// 新增的子类方法
Student.prototype.saySchool = function () {
  console.log(this.school);
};&lt;/p&gt;

&lt;p&gt;var person1 = new Person(‘Weiwei’, 27, ‘Student’);
var student1 = new Student(‘Lily’, 25, ‘Doctor’, “Southeast University”);&lt;/p&gt;

&lt;p&gt;console.log(person1.sayName === student1.sayName); // true&lt;/p&gt;

&lt;p&gt;person1.sayName();  // Weiwei
student1.sayName(); // Lily
student1.saySchool(); // Southeast University
```&lt;/p&gt;

&lt;p&gt;组合集成避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为了JavaScript中最常用的继承模式。
而且，&lt;code class=&quot;highlighter-rouge&quot;&gt;instanceof&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;isPropertyOf()&lt;/code&gt;也能够用于识别基于组合继承创建的对象。&lt;/p&gt;

&lt;h3 id=&quot;objectcreate&quot;&gt;组合继承的改进版：使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.create()&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;在上面，我们继承父类的原型方法使用的是&lt;code class=&quot;highlighter-rouge&quot;&gt;Student.prototype = new Person()&lt;/code&gt;。
这样做&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript&quot;&gt;有很多的问题&lt;/a&gt;。
改进方法是使用ES5中新增的&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.create()&lt;/code&gt;。可以调用这个方法来创建一个新对象。新对象的原型就是调用&lt;code class=&quot;highlighter-rouge&quot;&gt;create()&lt;/code&gt;方法传入的第一个参数：&lt;/p&gt;

&lt;p&gt;```javascript
Student.prototype = Object.create(Person.prototype);&lt;/p&gt;

&lt;p&gt;console.log(Student.prototype.constructor); // [Function: Person]&lt;/p&gt;

&lt;p&gt;// 设置 constructor 属性指向 Student
Student.prototype.constructor = Student;
```&lt;/p&gt;

&lt;p&gt;详细用法可以&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create&quot;&gt;参考文档&lt;/a&gt;。
关于&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.create()&lt;/code&gt;的实现，我们可以参考一个简单的polyfill：&lt;/p&gt;

&lt;p&gt;```javascript
function createObject(proto) {
    function F() { }
    F.prototype = proto;
    return new F();
}&lt;/p&gt;

&lt;p&gt;// Usage:
Student.prototype = createObject(Person.prototype);
```&lt;/p&gt;

&lt;p&gt;从本质上讲，&lt;code class=&quot;highlighter-rouge&quot;&gt;createObject()&lt;/code&gt;对传入其中的对象执行了一次浅复制。&lt;/p&gt;

&lt;h2 id=&quot;es6&quot;&gt;ES6中的面向对象语法&lt;/h2&gt;

&lt;p&gt;ES6中引入了一套新的关键字用来实现&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes&quot;&gt;class&lt;/a&gt;。
但它并不是映入了一种新的面向对象继承模式。JavaScript仍然是基于原型的，这些新的关键字包括&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/class&quot;&gt;class&lt;/a&gt;、
&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/constructor&quot;&gt;constructor&lt;/a&gt;、
&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/static&quot;&gt;static&lt;/a&gt;、
&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/extends&quot;&gt;extends&lt;/a&gt;、
和&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super&quot;&gt;super&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt;关键字不过是提供了一种在本文中所讨论的基于原型模式和构造器模式的面向对象的继承方式的&lt;strong&gt;语法糖(syntactic sugar)&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;对前面的代码修改如下：&lt;/p&gt;

&lt;p&gt;```javascript
‘use strict’;&lt;/p&gt;

&lt;p&gt;class Person {&lt;/p&gt;

&lt;p&gt;constructor (name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
  }&lt;/p&gt;

&lt;p&gt;sayName () {
    console.log(this.name);
  }&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;class Student extends Person {&lt;/p&gt;

&lt;p&gt;constructor (name, age, school) {
    super(name, age, ‘Student’);
    this.school = school;
  }&lt;/p&gt;

&lt;p&gt;saySchool () {
    console.log(this.school);
  }&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;var stu1 = new Student(‘weiwei’, 20, ‘Southeast University’);
var stu2 = new Student(‘lily’, 22, ‘Nanjing University’);&lt;/p&gt;

&lt;p&gt;stu1.sayName(); // weiwei
stu1.saySchool(); // Southeast University&lt;/p&gt;

&lt;p&gt;stu2.sayName(); // lily
stu2.saySchool(); // Nanjing University
```&lt;/p&gt;

&lt;h3 id=&quot;class&quot;&gt;类：&lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;是JavaScript中现有基于原型的继承的语法糖。ES6中的&lt;strong&gt;类&lt;/strong&gt;并不是一种新的创建对象的方法，只不过是一种“特殊的函数”，
因此也包括&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/class&quot;&gt;类表达式&lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/class&quot;&gt;类声明&lt;/a&gt;，
但需要注意的是，与函数声明不同的是，类声明不会被&lt;a href=&quot;http://www.sitepoint.com/back-to-basics-javascript-hoisting/&quot;&gt;提升&lt;/a&gt;。
&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/class&quot;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;constructor&quot;&gt;类构造器：&lt;code class=&quot;highlighter-rouge&quot;&gt;constructor&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;constructor()&lt;/code&gt;方法是有一种特殊的和&lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt;一起用于创建和初始化对象的方法。注意，在ES6类中只能有一个名称为&lt;code class=&quot;highlighter-rouge&quot;&gt;constructor&lt;/code&gt;的方法，
否则会报错。在&lt;code class=&quot;highlighter-rouge&quot;&gt;constructor()&lt;/code&gt;方法中可以调用&lt;code class=&quot;highlighter-rouge&quot;&gt;super&lt;/code&gt;关键字调用父类构造器。如果你没有指定一个构造器方法，
类会自动使用一个默认的构造器。&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor&quot;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;static&quot;&gt;类的静态方法：&lt;code class=&quot;highlighter-rouge&quot;&gt;static&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;静态方法就是可以直接使用类名调用的方法，而无需对类进行实例化，当然实例化后的类也无法调用静态方法。
静态方法常被用于创建应用的工具函数。&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static&quot;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;extends&quot;&gt;继承父类：&lt;code class=&quot;highlighter-rouge&quot;&gt;extends&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;extends&lt;/code&gt;关键字可以用于继承父类。使用&lt;code class=&quot;highlighter-rouge&quot;&gt;extends&lt;/code&gt;可以扩展一个内置的对象（如&lt;code class=&quot;highlighter-rouge&quot;&gt;Date&lt;/code&gt;），也可以是自定义对象，或者是&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;super&quot;&gt;关键字：&lt;code class=&quot;highlighter-rouge&quot;&gt;super&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;super&lt;/code&gt;关键字用于调用父对象上的函数。
&lt;code class=&quot;highlighter-rouge&quot;&gt;super.prop&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;super[expr]&lt;/code&gt;表达式在类和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer&quot;&gt;对象字面量&lt;/a&gt;中的任何&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions&quot;&gt;方法定义&lt;/a&gt;中都有效。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
super([arguments]); // 调用父类构造器
super.functionOnParent([arguments]); // 调用父类中的方法
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果是在类的构造器中，需要在&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;关键字之前使用。&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super&quot;&gt;参考链接&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-15&quot;&gt;小结&lt;/h2&gt;

&lt;p&gt;本文对JavaScript的面向对象机制进行了较为深入的解读，尤其是构造函数和原型链方式实现对象的创建、继承、以及实例化。
此外，本文还简要介绍了如在ES6中编写面向对象代码。&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://luopq.com/2016/02/28/Object-in-Javascript&quot;&gt;详解Javascript中的Object对象&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt;操作符&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript&quot;&gt;JavaScript面向对象简介&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create&quot;&gt;Object.create()&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain&quot;&gt;继承与原型链&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://bytearcher.com/articles/understanding-prototype-property-in-javascript/&quot;&gt;Understanding the prototype property in JavaScript&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 09 Mar 2016 00:00:00 +0800</pubDate>
        <link>twolun.github.com/posts/javascript-oo-summary.html</link>
        <guid isPermaLink="true">twolun.github.com/posts/javascript-oo-summary.html</guid>
        
        
        <category>technique</category>
        
      </item>
    
      <item>
        <title>使用Generators和Promises实现异步I/O</title>
        <description>&lt;p&gt;本文主要介绍的是如何利用ES6的生成器来设计API，用于解决异步的数据输入和输出问题。
此外，还能够使用Promise来将一组操作链接起来。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;statement&quot;&gt;Statement&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;原文地址：&lt;/strong&gt;https://ponyfoo.com/articles/asynchronous-i-o-with-generators-and-promises&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;译者：&lt;/strong&gt;&lt;a href=&quot;http://wwsun.github.com&quot;&gt;景庄&lt;/a&gt;，Web开发者，主要关注JavaScript、Node.js、React、Docker等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对我而言，在阅读一本工程技术类的书籍而言，其中最有趣的部分往往是其中的示例部分，
并且对于作者而言，示例部分也是在写一本引人入胜的技术材料时最难的以部分。
我发现最好的例子是那些能够带着你思考API设计和编码实践的例子，而不是那些单纯的介绍特定语言特性的例子。
即使这样，如果你已经通过实例理解了语言特性，你可能还是要通过一些有趣的例子来发现其使用价值（practical）。&lt;/p&gt;

&lt;p&gt;下面所描述的问题的例子包括了寻找在生成器函数中使用&lt;code class=&quot;highlighter-rouge&quot;&gt;return&lt;/code&gt;语句的用处。
&lt;a href=&quot;https://ponyfoo.com/articles/es6-generators-in-depth&quot;&gt;正如我们知道的那样&lt;/a&gt;，
生成器函数对待&lt;code class=&quot;highlighter-rouge&quot;&gt;return&lt;/code&gt;语句的方式与&lt;code class=&quot;highlighter-rouge&quot;&gt;yield&lt;/code&gt;表达式并不同。我们先来看下面这个使用生成器的例子：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
function* numbers() {
  yield 1;
  yield 2;
  return 3;
  yield 4;
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果我们使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Array.from(numbers()), [...numbers()]&lt;/code&gt;，或者甚至是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;for...of&lt;/code&gt;循环，
我们将只能看到输出结果为&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;。然而，如果我们更进一步的，并使用生成器对象的话，
我们将在输出结果中看到&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt; —— 即使迭代器结果会提示&lt;code class=&quot;highlighter-rouge&quot;&gt;done: true&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
var g = numbers();
console.log(g.next());
// &amp;lt;- { done: false, value: 1 }
console.log(g.next());
// &amp;lt;- { done: false, value: 2 }
console.log(g.next());
// &amp;lt;- { done: true, value: 3 }
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在上面我所给出的例子中，函数调用的其实是一个生成器函数（&lt;code class=&quot;highlighter-rouge&quot;&gt;numbers&lt;/code&gt;），
我们通过&lt;code class=&quot;highlighter-rouge&quot;&gt;yield&lt;/code&gt;关键字获取需要被持有的资源，然后在你需要保存（persist）这些资源的时候，
&lt;code class=&quot;highlighter-rouge&quot;&gt;return&lt;/code&gt;端点（endpoint）。迭代器将会每次一个的拉取资源，并最终为每一个资源推送数据到另一个端点，
可以假定为将所有的数据保存在一个对象中。&lt;/p&gt;

&lt;h2 id=&quot;api&quot;&gt;API设计&lt;/h2&gt;

&lt;p&gt;上面所说的问题中的API可以参考下面的代码。&lt;code class=&quot;highlighter-rouge&quot;&gt;saveProducts&lt;/code&gt;方法将会&lt;code class=&quot;highlighter-rouge&quot;&gt;GET&lt;/code&gt;一系列产品的JSON描述，
并且将产品的数据&lt;code class=&quot;highlighter-rouge&quot;&gt;POST&lt;/code&gt;到用户的购物车中。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
saveProducts(function* () {
  yield &#39;/products/javascript-application-design&#39;; // 获取产品1
  yield &#39;/products/barbie-doll&#39;; // 获取产品2
  return &#39;/cart&#39;; // 将产品1和2的数据上传给购物车
});
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;此外，我认为如果&lt;code class=&quot;highlighter-rouge&quot;&gt;saveProducts&lt;/code&gt;能返回一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Promise&lt;/code&gt;对象的话将会变得更加每秒，
因为这意味着开发者可以在产品被保存到购物车后，继续&lt;a href=&quot;https://ponyfoo.com/articles/es6-promises-in-depth&quot;&gt;链接一系列的其他操作&lt;/a&gt;。
例如：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
saveProducts(productList)
  .then(data =&amp;gt; console.log(&#39;Saved&#39;, data));
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;当然，也可以加入一些条件逻辑来允许这个假设方法能够将产品保存到心愿列表中，而不是保存到购物车中。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
saveProducts(function* () {
  yield &#39;/products/javascript-application-design&#39;;
  yield &#39;/products/barbie-doll&#39;;
  if (addToCart) {
    return &#39;/cart&#39;; // 保存到购物车
  }
  return &#39;/wishlists/nerd-items&#39;; // 保存到心愿列表
})
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个例子也可以应用到服务端，每一个被yield的值都可能导致一次数据库查询，
并且所返回的值也可以表示某种我们想要保存回数据库中的对象。相似的，迭代器可以决定所yield输入值被处理的节奏：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可以是一个非常简单的同步队列&lt;/li&gt;
  &lt;li&gt;可以是并行处理所有查询&lt;/li&gt;
  &lt;li&gt;可以是一个有限并发的并行队列&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;无论如何，API可以或多或少的保持一致，这取决于消费者是否希望在生成器中使用产品数据。&lt;/p&gt;

&lt;h2 id=&quot;saveproducts&quot;&gt;实现&lt;code class=&quot;highlighter-rouge&quot;&gt;saveProducts&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;首先，在上面所讨论的问题中的方法中接收了一个生成器，并初始化了该生成器对象用于迭代生成器函数所产生的值。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
function saveProducts (productList) {
  var g = productList; // productList是一个生成器函数
}
&lt;/code&gt;
### 简单实现&lt;/p&gt;

&lt;p&gt;使用简单的实现方案，我们可以在一个异步序列模式中逐个的拉取产品。代码片段如下所示，
该例子使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt;来拉取用户提供的生成器所yield的资源 —— 作为JSON。&lt;/p&gt;

&lt;p&gt;```javascript
function saveProducts (productList) {
  var g = productList(); // productList是一个生成器函数
  var item = g.next();
  more();&lt;/p&gt;

&lt;p&gt;function more () {
    if (item.done) {
      return;
    }
    fetch(item.value)
      .then(res =&amp;gt; res.json())
      .then(product =&amp;gt; {
        item = g.next(product);
        more();
      });
  }
}&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;通过调用&lt;code class=&quot;highlighter-rouge&quot;&gt;g.next(product)&lt;/code&gt;，我们能够允许消费者通过&lt;code class=&quot;highlighter-rouge&quot;&gt;data = yield &#39;/resource&#39;&lt;/code&gt;这种方式读取产品数据。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;到目前为止，我们拉取所有的数据（获取商品信息），并将它传递回（保存到购物车），对于生成器而言是逐个的进行传递的，
这让我们感觉代码好像是同步的一样。为了能够利用&lt;code class=&quot;highlighter-rouge&quot;&gt;return&lt;/code&gt;语句，我们需要将产品保存到一个临时的数组中，
当迭代结束的时候，我们再将它们&lt;code class=&quot;highlighter-rouge&quot;&gt;POST&lt;/code&gt;回去（保存到购物车）。&lt;/p&gt;

&lt;p&gt;```javascript
function saveProducts (productList) {
  var products = [];
  var g = productList();
  var item = g.next();
  more();&lt;/p&gt;

&lt;p&gt;function more () {
    if (item.done) {
      save(item.value);
    } else {
      details(item.value);
    }
  }&lt;/p&gt;

&lt;p&gt;// 获取商品信息
  function details (endpoint) {
    fetch(endpoint)
      .then(res =&amp;gt; res.json())
      .then(product =&amp;gt; {
        products.push(product);
        item = g.next(product);
        more();
      });
  }&lt;/p&gt;

&lt;p&gt;// 保存产品列表数据
  function save (endpoint) {
    fetch(endpoint, {
      method: ‘POST’,
      body: JSON.stringify({ products })
    });
  }
}&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;此时，我们获取了产品的描述信息，并将它们缓存到了&lt;code class=&quot;highlighter-rouge&quot;&gt;products&lt;/code&gt;数组中，转发给生成器的函数体，
并最终通过&lt;code class=&quot;highlighter-rouge&quot;&gt;return&lt;/code&gt;语句所提供的端点进行保存。那么如何支持&lt;code class=&quot;highlighter-rouge&quot;&gt;Promise&lt;/code&gt;呢？这些非常容易添加进来：
&lt;code class=&quot;highlighter-rouge&quot;&gt;fetch&lt;/code&gt;返回的是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Promise&lt;/code&gt;对象，并且它&lt;code class=&quot;highlighter-rouge&quot;&gt;return&lt;/code&gt; all the way down。&lt;/p&gt;

&lt;p&gt;```javascript
function saveProducts (productList) {
  var products = [];
  var g = productList();
  var item = g.next();
  return more();&lt;/p&gt;

&lt;p&gt;function more () {
    if (item.done) {
      return save(item.value);
    }
    return details(item.value);
  }&lt;/p&gt;

&lt;p&gt;function details (endpoint) {
    // 直接返回fetch
    return fetch(endpoint)
      .then(res =&amp;gt; res.json())
      .then(product =&amp;gt; {
        products.push(product);
        item = g.next(product);
        return more();
      });
  }&lt;/p&gt;

&lt;p&gt;function save (endpoint) {
    // 直接返回fetch
    return fetch(endpoint, {
        method: ‘POST’,
        body: JSON.stringify({ products })
      })
      .then(res =&amp;gt; res.json());
  }
}
```&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我们也需要将&lt;code class=&quot;highlighter-rouge&quot;&gt;save&lt;/code&gt;操作的响应结果转型为JSON，这样链接到&lt;code class=&quot;highlighter-rouge&quot;&gt;saveProducts&lt;/code&gt;上的Promise链就可以利用响应结果中的&lt;code class=&quot;highlighter-rouge&quot;&gt;data&lt;/code&gt;对象了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;正如你所看到的那样，该实现方法并没有对该操作的任何重要的方面进行硬编码实现，这意为着你可以在其他场景范范的使用这种模式，
也就是说，如果你拥有零个或多个输入，并且想要将它们拼接到同一个输出管道中。对消费者而言，它们最终获取到的是一个具有非常优雅外观的方法，
并且易于理解 —— 它们只需要&lt;code class=&quot;highlighter-rouge&quot;&gt;yield&lt;/code&gt;输入值，并&lt;code class=&quot;highlighter-rouge&quot;&gt;return&lt;/code&gt;输出值。此外，我们通过使用promise来使其更易于与其他操作相拼接。
这种方式下，我们能够控制条件语句和流程控制机制中的潜在混乱，这是通过将流程控制抽象到&lt;code class=&quot;highlighter-rouge&quot;&gt;saveProducts&lt;/code&gt;方法的迭代机制中进行实现的。&lt;/p&gt;
</description>
        <pubDate>Mon, 07 Mar 2016 00:00:00 +0800</pubDate>
        <link>twolun.github.com/posts/async-io-with-generators-and-promises.html</link>
        <guid isPermaLink="true">twolun.github.com/posts/async-io-with-generators-and-promises.html</guid>
        
        
        <category>knowledge</category>
        
      </item>
    
      <item>
        <title>理解JavaScript中的作用域和上下文</title>
        <description>&lt;p&gt;JavaScript对于作用域（Scope）和上下文（Context）的实现是这门语言的一个非常独到的地方，部分归功于其独特的灵活性。
函数可以接收不同的的上下文和作用域。这些概念为JavaScript中的很多强大的设计模式提供了坚实的基础。
然而这也概念也非常容易给开发人员带来困惑。为此，本文将全面的剖析这些概念，并阐述不同的设计模式是如何利用它们的。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;statement&quot;&gt;Statement&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;作者：&lt;/strong&gt; &lt;a href=&quot;http://wwsun.github.com&quot;&gt;景庄&lt;/a&gt;，Web开发者，主要关注JavaScript、Node.js、React、Docker等。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;原文地址：&lt;/strong&gt; http://ryanmorr.com/understanding-scope-and-context-in-javascript/&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;contextscope&quot;&gt;上下文（Context）和作用域（Scope）&lt;/h2&gt;

&lt;p&gt;首先需要知道的是，上下文和作用域是两个完全不同的概念。多年来，我发现很多开发者会混淆这两个概念（包括我自己），
错误的将两个概念混淆了。平心而论，这些年来很多术语都被混乱的使用了。&lt;/p&gt;

&lt;p&gt;函数的每次调用都有与之紧密相关的作用域和上下文。从根本上来说，作用域是基于函数的，而上下文是基于对象的。
换句话说，作用域涉及到所被调用函数中的变量访问，并且不同的调用场景是不一样的。上下文始终是&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;关键字的值，
它是拥有（控制）当前所执行代码的对象的引用。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;变量作用域&lt;/h2&gt;

&lt;p&gt;一个变量可以被定义在局部或者全局作用域中，这建立了在运行时（runtime）期间变量的访问性的不同作用域范围。
任何被定义的全局变量，意味着它需要在函数体的外部被声明，并且存活于整个运行时（runtime），并且在任何作用域中都可以被访问到。
在ES6之前，局部变量只能存在于函数体中，并且函数的每次调用它们都拥有不同的作用域范围。
局部变量只能在其被调用期的作用域范围内被赋值、检索、操纵。&lt;/p&gt;

&lt;p&gt;需要注意，在ES6之前，JavaScript不支持块级作用域，这意味着在&lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt;语句、&lt;code class=&quot;highlighter-rouge&quot;&gt;switch&lt;/code&gt;语句、&lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt;循环、&lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt;循环中无法支持块级作用域。
也就是说，ES6之前的JavaScript并不能构建类似于Java中的那样的块级作用域（变量不能在语句块外被访问到）。但是，
从ES6开始，你可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;关键字来定义变量，它修正了&lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;关键字的缺点，能够让你像Java语言那样定义变量，并且支持块级作用域。看两个例子：&lt;/p&gt;

&lt;p&gt;ES6之前，我们使用&lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;关键字定义变量：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
function func() {
  if (true) {
    var tmp = 123;
  }
  console.log(tmp); // 123
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;之所以能够访问，是因为&lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;关键字声明的变量有一个变量提升的过程。而在ES6场景，推荐使用&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;关键字定义变量：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
function func() {
  if (true) {
    let tmp = 123;
  }
  console.log(tmp); // ReferenceError: tmp is not defined
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这种方式，能够避免很多错误。&lt;/p&gt;

&lt;h2 id=&quot;this&quot;&gt;什么是&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;上下文&lt;/h2&gt;

&lt;p&gt;上下文通常取决于函数是如何被调用的。当一个函数被作为对象中的一个方法被调用的时候，&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;被设置为调用该方法的对象上：&lt;/p&gt;

&lt;p&gt;```javascript
var obj = {
    foo: function(){
        alert(this === obj);  &lt;br /&gt;
    }
};&lt;/p&gt;

&lt;p&gt;obj.foo(); // true
```&lt;/p&gt;

&lt;p&gt;这个准则也适用于当调用函数时使用&lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt;操作符来创建对象的实例的情况下。在这种情况下，在函数的作用域内部&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;的值被设置为新创建的实例：&lt;/p&gt;

&lt;p&gt;```javascript
function foo(){
    alert(this);
}&lt;/p&gt;

&lt;p&gt;new foo() // foo
foo() // window
```&lt;/p&gt;

&lt;p&gt;当调用一个为绑定函数时，&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;默认情况下是全局上下文，在浏览器中它指向&lt;code class=&quot;highlighter-rouge&quot;&gt;window&lt;/code&gt;对象。需要注意的是，ES5引入了严格模式的概念，
如果启用了严格模式，此时上下文默认为&lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;execution-context&quot;&gt;执行环境（execution context）&lt;/h2&gt;

&lt;p&gt;JavaScript是一个单线程语言，意味着同一时间只能执行一个任务。当JavaScript解释器初始化执行代码时，
它首先默认进入全局执行环境（execution context），从此刻开始，函数的每次调用都会创建一个新的执行环境。&lt;/p&gt;

&lt;p&gt;这里会经常引起新手的困惑，这里提到了一个新的术语——&lt;strong&gt;执行环境&lt;/strong&gt;（execution context），它定义了变量或函数有权访问的其他数据，决定了它们各自的行为。
它更偏向于作用域的作用，而不是我们前面讨论的&lt;strong&gt;上下文&lt;/strong&gt;（Context）。请务必仔细的区分执行环境和上下文这两个概念（注：英文容易造成混淆）。
说实话，这是个非常糟糕的命名约定，但是它是ECMAScript规范制定的，你还是遵守吧。&lt;/p&gt;

&lt;p&gt;每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中（execution stack）。在函数执行完后，栈将其环境弹出，
把控制权返回给之前的执行环境。ECMAScript程序中的执行流正是由这个便利的机制控制着。&lt;/p&gt;

&lt;p&gt;执行环境可以分为创建和执行两个阶段。在创建阶段，解析器首先会创建一个变量对象（variable object，也称为活动对象 activation object），
它由定义在执行环境中的变量、函数声明、和参数组成。在这个阶段，作用域链会被初始化，&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;的值也会被最终确定。
在执行阶段，代码被解释执行。&lt;/p&gt;

&lt;p&gt;每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。
需要知道，我们无法手动访问这个对象，只有解析器才能访问它。&lt;/p&gt;

&lt;h2 id=&quot;the-scope-chain&quot;&gt;作用域链（The Scope Chain）&lt;/h2&gt;

&lt;p&gt;当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。
作用域链包含了在环境栈中的每个执行环境对应的变量对象。通过作用域链，可以决定变量的访问和标识符的解析。
注意，全局执行环境的变量对象始终都是作用域链的最后一个对象。我们来看一个例子：&lt;/p&gt;

&lt;p&gt;```javascript
var color = “blue”;&lt;/p&gt;

&lt;p&gt;function changeColor(){
  var anotherColor = “red”;&lt;/p&gt;

&lt;p&gt;function swapColors(){
    var tempColor = anotherColor;
    anotherColor = color;
    color = tempColor;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 这里可以访问color, anotherColor, 和 tempColor   }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;// 这里可以访问color 和 anotherColor，但是不能访问 tempColor
  swapColors();
}&lt;/p&gt;

&lt;p&gt;changeColor();&lt;/p&gt;

&lt;p&gt;// 这里只能访问color
console.log(“Color is now “ + color);
```&lt;/p&gt;

&lt;p&gt;上述代码一共包括三个执行环境：全局环境、changeColor()的局部环境、swapColors()的局部环境。
上述程序的作用域链如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xpv9g.com1.z0.glb.clouddn.com/imgscope-chain.png&quot; alt=&quot;scope chain example&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从上图发现。内部环境可以通过作用域链访问所有的外部环境，但是外部环境不能访问内部环境中的任何变量和函数。
这些环境之间的联系是线性的、有次序的。&lt;/p&gt;

&lt;p&gt;对于标识符解析（变量名或函数名搜索）是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，
然后逐级地向后（全局执行环境）回溯，直到找到标识符为止。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;闭包&lt;/h2&gt;

&lt;p&gt;闭包是指有权访问另一函数作用域中的变量的函数。换句话说，在函数内定义一个嵌套的函数时，就构成了一个闭包，
它允许嵌套函数访问外层函数的变量。通过返回嵌套函数，允许你维护对外部函数中局部变量、参数、和内函数声明的访问。
这种封装允许你在外部作用域中隐藏和保护执行环境，并且暴露公共接口，进而通过公共接口执行进一步的操作。可以看个简单的例子：&lt;/p&gt;

&lt;p&gt;```javascript
function foo(){
    var localVariable = ‘private variable’;
    return function bar(){
        return localVariable;
    }
}&lt;/p&gt;

&lt;p&gt;var getLocalVariable = foo();
getLocalVariable() // private variable
```&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;模块模式&lt;/strong&gt;最流行的闭包类型之一，它允许你模拟公共的、私有的、和特权成员：&lt;/p&gt;

&lt;p&gt;```javascript
var Module = (function(){
    var privateProperty = ‘foo’;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function privateMethod(args){
    // do something
}

return {

    publicProperty: &#39;&#39;,

    publicMethod: function(args){
        // do something
    },

    privilegedMethod: function(args){
        return privateMethod(args);
    }
}; })(); ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;模块类似于一个单例对象。由于在上面的代码中我们利用了&lt;code class=&quot;highlighter-rouge&quot;&gt;(function() { ... })();&lt;/code&gt;的匿名函数形式，因此当编译器解析它的时候会立即执行。
在闭包的执行上下文的外部唯一可以访问的对象是位于返回对象中的公共方法和属性。然而，因为执行上下文被保存的缘故，
所有的私有属性和方法将一直存在于应用的整个生命周期，这意味着我们只有通过公共方法才可以与它们交互。&lt;/p&gt;

&lt;p&gt;另一种类型的闭包被称为&lt;strong&gt;立即执行的函数表达式（IIFE）&lt;/strong&gt;。其实它很简单，只不过是一个在全局环境中自执行的匿名函数而已：&lt;/p&gt;

&lt;p&gt;```javascript
(function(window){&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var foo, bar;

function private(){
    // do something
}

window.Module = {

    public: function(){
        // do something 
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;})(this);
```&lt;/p&gt;

&lt;p&gt;对于保护全局命名空间免受变量污染而言，这种表达式非常有用，它通过构建函数作用域的形式将变量与全局命名空间隔离，
并通过闭包的形式让它们存在于整个运行时（runtime）。在很多的应用和框架中，这种封装源代码的方式用处非常的流行，
通常都是通过暴露一个单一的全局接口的方式与外部进行交互。&lt;/p&gt;

&lt;h2 id=&quot;callapply&quot;&gt;Call和Apply&lt;/h2&gt;

&lt;p&gt;这两个方法内建在所有的函数中（它们是&lt;code class=&quot;highlighter-rouge&quot;&gt;Function&lt;/code&gt;对象的原型方法），允许你在自定义上下文中执行函数。
不同点在于，&lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt;函数需要参数列表，而&lt;code class=&quot;highlighter-rouge&quot;&gt;apply&lt;/code&gt;函数需要你提供一个参数数组。如下：&lt;/p&gt;

&lt;p&gt;```javascript
var o = {};&lt;/p&gt;

&lt;p&gt;function f(a, b) {
  return a + b;
}&lt;/p&gt;

&lt;p&gt;// 将函数f作为o的方法，实际上就是重新设置函数f的上下文
f.call(o, 1, 2);    // 3
f.apply(o, [1, 2]); // 3
```&lt;/p&gt;

&lt;p&gt;两个结果是相同的，函数&lt;code class=&quot;highlighter-rouge&quot;&gt;f&lt;/code&gt;在对象&lt;code class=&quot;highlighter-rouge&quot;&gt;o&lt;/code&gt;的上下文中被调用，并提供了两个相同的参数&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在ES5中引入了&lt;code class=&quot;highlighter-rouge&quot;&gt;Function.prototype.bind&lt;/code&gt;方法，用于控制函数的执行上下文，它会返回一个新的函数，
并且这个新函数会被永久的绑定到&lt;code class=&quot;highlighter-rouge&quot;&gt;bind&lt;/code&gt;方法的第一个参数所指定的对象上，无论该函数被如何使用。
它通过闭包将函数引导到正确的上下文中。对于低版本浏览器，我们可以简单的对它进行实现如下（polyfill）：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
if(!(&#39;bind&#39; in Function.prototype)){
    Function.prototype.bind = function(){
        var fn = this, 
            context = arguments[0], 
            args = Array.prototype.slice.call(arguments, 1);
        return function(){
            return fn.apply(context, args.concat(arguments));
        }
    }
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bind()&lt;/code&gt;方法通常被用在上下文丢失的场景下，例如面向对象和事件处理。之所以要这么做，
是因为节点的&lt;code class=&quot;highlighter-rouge&quot;&gt;addEventListener&lt;/code&gt;方法&lt;strong&gt;总是为事件处理器所绑定的节点的上下文&lt;/strong&gt;中执行回调函数，
这就是它应该表现的那样。但是，如果你想要使用高级的面向对象技术，或需要你的回调函数成为某个方法的实例，
你将需要手动调整上下文。这就是&lt;code class=&quot;highlighter-rouge&quot;&gt;bind&lt;/code&gt;方法所带来的便利之处：&lt;/p&gt;

&lt;p&gt;```javascript
function MyClass(){
    this.element = document.createElement(‘div’);
    this.element.addEventListener(‘click’, this.onClick.bind(this), false);
}&lt;/p&gt;

&lt;p&gt;MyClass.prototype.onClick = function(e){
    // do something
};
```&lt;/p&gt;

&lt;p&gt;回顾上面&lt;code class=&quot;highlighter-rouge&quot;&gt;bind&lt;/code&gt;方法的源代码，你可能会注意到有两次调用涉及到了&lt;code class=&quot;highlighter-rouge&quot;&gt;Array&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;slice&lt;/code&gt;方法：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
Array.prototype.slice.call(arguments, 1);
[].slice.call(arguments);
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我们知道，&lt;code class=&quot;highlighter-rouge&quot;&gt;arguments&lt;/code&gt;对象并不是一个真正的数组，而是一个类数组对象，虽然具有length属性，并且值也能够被索引，
但是它们不支持原生的数组方法，例如&lt;code class=&quot;highlighter-rouge&quot;&gt;slice&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;push&lt;/code&gt;。但是，由于它们具有和数组类似的行为，数组的方法能够被调用和劫持，
因此我们可以通过类似于上面代码的方式达到这个目的，其核心是利用&lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt;方法。&lt;/p&gt;

&lt;p&gt;这种调用其他对象方法的技术也可以被应用到面向对象中，我们可以在JavaScript中模拟经典的继承方式：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
MyClass.prototype.init = function(){
    // call the superclass init method in the context of the &quot;MyClass&quot; instance
    MySuperClass.prototype.init.apply(this, arguments);
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;也就是利用&lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;apply&lt;/code&gt;在子类（&lt;code class=&quot;highlighter-rouge&quot;&gt;MyClass&lt;/code&gt;）的实例中调用超类（&lt;code class=&quot;highlighter-rouge&quot;&gt;MySuperClass&lt;/code&gt;）的方法。&lt;/p&gt;

&lt;h2 id=&quot;es6&quot;&gt;ES6中的箭头函数&lt;/h2&gt;

&lt;p&gt;ES6中的箭头函数可以作为&lt;code class=&quot;highlighter-rouge&quot;&gt;Function.prototype.bind()&lt;/code&gt;的替代品。和普通函数不同，箭头函数没有它自己的&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;值，
它的&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;值继承自外围作用域。&lt;/p&gt;

&lt;p&gt;对于普通函数而言，它总会自动接收一个&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;值，&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;的指向取决于它调用的方式。我们来看一个例子：&lt;/p&gt;

&lt;p&gt;```javascript
var obj = {&lt;/p&gt;

&lt;p&gt;// …&lt;/p&gt;

&lt;p&gt;addAll: function (pieces) {
    var self = this;
    _.each(pieces, function (piece) {
      self.add(piece);
    });
  },&lt;/p&gt;

&lt;p&gt;// …&lt;/p&gt;

&lt;p&gt;}
```&lt;/p&gt;

&lt;p&gt;在上面的例子中，最直接的想法是直接使用&lt;code class=&quot;highlighter-rouge&quot;&gt;this.add(piece)&lt;/code&gt;，但不幸的是，在JavaScript中你不能这么做，
因为&lt;code class=&quot;highlighter-rouge&quot;&gt;each&lt;/code&gt;的回调函数并未从外层继承&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;值。在该回调函数中，&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;的值为&lt;code class=&quot;highlighter-rouge&quot;&gt;window&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;，
因此，我们使用临时变量&lt;code class=&quot;highlighter-rouge&quot;&gt;self&lt;/code&gt;来将外部的&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;值导入内部。我们还有两种方法解决这个问题：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用ES5中的bind()方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;```javascript
var obj = {&lt;/p&gt;

&lt;p&gt;// …&lt;/p&gt;

&lt;p&gt;addAll: function (pieces) {
    _.each(pieces, function (piece) {
      this.add(piece);
    }.bind(this));
  },&lt;/p&gt;

&lt;p&gt;// …&lt;/p&gt;

&lt;p&gt;}
```&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用ES6中的箭头函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;```javascript
var obj = {&lt;/p&gt;

&lt;p&gt;// …&lt;/p&gt;

&lt;p&gt;addAll: function (pieces) {
    _.each(pieces, piece =&amp;gt; this.add(piece));
  },&lt;/p&gt;

&lt;p&gt;// …&lt;/p&gt;

&lt;p&gt;}
```&lt;/p&gt;

&lt;p&gt;在ES6版本中，&lt;code class=&quot;highlighter-rouge&quot;&gt;addAll&lt;/code&gt;方法从它的调用者处获得了&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;值，内部函数是一个箭头函数，所以它集成了外部作用域的&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;对回调函数而言，在浏览器中，回调函数中的&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;window&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;（严格模式），而在Node.js中，
回调函数的&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;global&lt;/code&gt;。实例代码如下：&lt;/p&gt;

&lt;p&gt;```javascript
function hello(a, callback) {
  callback(a);
}&lt;/p&gt;

&lt;p&gt;hello(‘weiwei’, function(a) {
  console.log(this === global); // true
  console.log(a); // weiwei
});
```&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;小结&lt;/h2&gt;

&lt;p&gt;在你学习高级的设计模式之前，理解这些概念非常的重要，因为作用域和上下文在现代JavaScript中扮演着的最基本的角色。
无论我们谈论的是闭包、面向对象、继承、或者是各种原生实现，上下文和作用域都在其中扮演着至关重要的角色。
如果你的目标是精通JavaScript语言，并且深入的理解它的各个组成，那么作用域和上下文便是你的起点。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;参考资料&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://ryanmorr.com/understanding-scope-and-context-in-javascript/&quot;&gt;Understanding Scope and Context in JavaScript&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;JavaScript高级程序设计，section 4.2&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.2ality.com/2016/02/arrow-functions-vs-bind.html&quot;&gt;Arrow functions vs. bind()&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.html-js.com/article/Sexy-Javascript-understand-the-callback-function-with-the-use-of-Javascript-in&quot;&gt;理解与使用Javascript中的回调函数&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 04 Mar 2016 00:00:00 +0800</pubDate>
        <link>twolun.github.com/posts/scope-and-context-in-javascript.html</link>
        <guid isPermaLink="true">twolun.github.com/posts/scope-and-context-in-javascript.html</guid>
        
        
        <category>knowledge</category>
        
      </item>
    
      <item>
        <title>使用Gulp.js来自动化你的任务</title>
        <description>&lt;p&gt;作为开发者而言，我们需要经常确保自己使用了合适的开发工具来提高我们的开发效率。对于JavaScript的项目构建而言，
Chris开发了Grunt，它极大的便利了项目的构建工作。本文将会介绍一个比Grunt更优雅的项目构建工具——Gulp。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;statement&quot;&gt;Statement&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;作者：&lt;/strong&gt; &lt;a href=&quot;http://wwsun.github.com&quot;&gt;景庄&lt;/a&gt;，Web开发者，主要关注JavaScript、Node.js、React、Docker等。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;gulpjs&quot;&gt;Gulp.js&lt;/h2&gt;

&lt;p&gt;在几个月前，我&lt;a href=&quot;http://wwsun.github.io/posts/grunt-getting-started.html&quot;&gt;曾经介绍过Grunt&lt;/a&gt;，
今天将要介绍的是一个和Grunt类似的构建工具——Gulp。
Gulp和Grunt都是完全使用JavaScript实现的构建工具，不过，Gulp是一个流式构建系统，
它完全借助了Node的流文件操纵功能，在内存中完成构建工作。整个插件都是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;pipe()&lt;/code&gt;函数来赋予。&lt;/p&gt;

&lt;p&gt;Gulp的最大特点在于流的使用，数据流能够同故宫一系列的小函数来传递数据，这些函数会对数据进行修改，
然后把修改后的数据传递给下一个函数。和Linux中的管道概念是一个意思。流可以相互链接。&lt;/p&gt;

&lt;p&gt;注意，Gulp管道中的流不是操作Strings和Buffers的常规Node.js流，
而是启用&lt;a href=&quot;https://nodejs.org/dist/latest-v4.x/docs/api/stream.html#stream_object_mode&quot;&gt;object mode&lt;/a&gt;的流。
Gulp中的流发送的是vinyl文件对象。&lt;/p&gt;

&lt;p&gt;有关Node中流的介绍，请参考&lt;a href=&quot;https://nodejs.org/dist/latest-v4.x/docs/api/stream.html#stream_stream&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;gulp&quot;&gt;安装Gulp&lt;/h2&gt;

&lt;p&gt;安装Gulp非常的简单，只要遵循下面三个步骤即可：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;全局安装Gulp&lt;/li&gt;
  &lt;li&gt;安装Gulp到项目的&lt;code class=&quot;highlighter-rouge&quot;&gt;devDependencies&lt;/code&gt;中&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在项目根目录创建&lt;code class=&quot;highlighter-rouge&quot;&gt;gulpfile.js&lt;/code&gt;文件&lt;/p&gt;

    &lt;p&gt;$ npm install -g gulp
 $ npm install –save-dev gulp&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们安装Gulp的工具插件用于可视化任务的执行过程：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm install --save-dev gulp-util
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在项目根目录创建完&lt;code class=&quot;highlighter-rouge&quot;&gt;gulpfile.js&lt;/code&gt;后，我们加入如下基础代码：&lt;/p&gt;

&lt;p&gt;```javascript
// grab our gulp packages
var gulp  = require(‘gulp’),
    gutil = require(‘gulp-util’);&lt;/p&gt;

&lt;p&gt;// create a default task and just log a message
gulp.task(‘default’, function() {
  return gutil.log(‘Gulp is running!’)
});
```&lt;/p&gt;

&lt;p&gt;现在你可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;gulp&lt;/code&gt;命令来启动Gulp。你可以在项目的&lt;code class=&quot;highlighter-rouge&quot;&gt;package.json&lt;/code&gt;文件中的&lt;code class=&quot;highlighter-rouge&quot;&gt;scripts&lt;/code&gt;属性中加入：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;gulp&quot;: &quot;gulp&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;gulp-1&quot;&gt;Gulp使用手册&lt;/h2&gt;

&lt;p&gt;Gulp是一个流式构建系统。它的流式特性意味着开发者&lt;/p&gt;

&lt;p&gt;Gulp API主要包括4个顶级函数。如下&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gulp.task(name, deps, fn)&lt;/code&gt;  定义任务&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gulp.src(globs, [opt])&lt;/code&gt;  指向我们想要操作的源文件&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gulp.dest&lt;/code&gt;  指向输出文件&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gulp.watch&lt;/code&gt;  用于监视文件的变化&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中文文档可以参考&lt;a href=&quot;https://github.com/lisposter/gulp-docs-zh-cn/blob/master/API.md&quot;&gt;该链接&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;gulptaskname-deps-fn&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gulp.task(name[, deps], fn)&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;用于定义Gulp任务。包括三个参数&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;name: 任务名，字符串&lt;/li&gt;
  &lt;li&gt;deps: 一组依赖任务的数组，它是可选的&lt;/li&gt;
  &lt;li&gt;fn: 执行任务的函数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;```javascript
gulp.task(‘mytask’, function() {
  //do stuff
});&lt;/p&gt;

&lt;p&gt;gulp.task(‘dependenttask’, [‘mytask’], function() {
  //do stuff after ‘mytask’ is done.
});
```&lt;/p&gt;

&lt;p&gt;详细内容请参考&lt;a href=&quot;https://github.com/lisposter/gulp-docs-zh-cn/blob/master/API.md#gulptaskname-deps-fn&quot;&gt;该链接&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;gulpsrcglobs-optionsgulpdestpath-options&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gulp.src(globs[, options])&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;gulp.dest(path[, options])&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gulp.src&lt;/code&gt;指向我们想要使用的文件。它的参数是globs和可选的选项对象。它使用&lt;code class=&quot;highlighter-rouge&quot;&gt;.pipe()&lt;/code&gt;将输出值链接（chaining）到其他插件中。&lt;/p&gt;

&lt;p&gt;详细内容请参考&lt;a href=&quot;https://github.com/lisposter/gulp-docs-zh-cn/blob/master/API.md#gulpsrcglobs-options&quot;&gt;该链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gulp.dest&lt;/code&gt;指向我们想要写入结果文件的输出文件夹。&lt;/p&gt;

&lt;p&gt;假如我们想要定义一个任务&lt;code class=&quot;highlighter-rouge&quot;&gt;copHtml&lt;/code&gt;将输入文件复制到输出文件夹中，代码如下：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
gulp.task(&#39;copyHtml&#39;, function() {
  // copy any html files in source/ to public/
  gulp.src(&#39;source/*.html&#39;).pipe(gulp.dest(&#39;public&#39;));
});
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;gulpwatchglob-opts-tasks&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gulp.watch(glob[, opts], tasks)&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;gulp.task&lt;/code&gt;类似，&lt;code class=&quot;highlighter-rouge&quot;&gt;gulp.watch&lt;/code&gt;也有一个可选的中间参数。&lt;code class=&quot;highlighter-rouge&quot;&gt;gulp.watch&lt;/code&gt;返回的是一个发射（emits）&lt;code class=&quot;highlighter-rouge&quot;&gt;change&lt;/code&gt;事件的&lt;code class=&quot;highlighter-rouge&quot;&gt;EventEmitter&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
gulp.watch(&#39;source/javascript/**/*.js&#39;, [&#39;jshint&#39;]);
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;匹配的任意文件如果发生了变化，就会自动触发&lt;code class=&quot;highlighter-rouge&quot;&gt;jshint&lt;/code&gt;任务。&lt;/p&gt;

&lt;p&gt;详细内容请参考&lt;a href=&quot;https://github.com/lisposter/gulp-docs-zh-cn/blob/master/API.md#gulpwatchglob--opts-tasks-或-gulpwatchglob--opts-cb&quot;&gt;该链接&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;常用任务&lt;/h2&gt;

&lt;h3 id=&quot;jshint&quot;&gt;JShint&lt;/h3&gt;

&lt;p&gt;每次我们保存一个JS文件的时候就利用JSHint进行代码检查。我们需要如下插件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm install --save-dev gulp-jshint jshint-stylish
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;任务编写如下：&lt;/p&gt;

&lt;p&gt;```javascript
// grab our packages
var gulp   = require(‘gulp’),
    jshint = require(‘gulp-jshint’);&lt;/p&gt;

&lt;p&gt;// define the default task and add the watch task to it
gulp.task(‘default’, [‘watch’]);&lt;/p&gt;

&lt;p&gt;// configure the jshint task
gulp.task(‘jshint’, function() {
  return gulp.src(‘source/javascript/&lt;em&gt;*/&lt;/em&gt;.js’)
    .pipe(jshint())
    .pipe(jshint.reporter(‘jshint-stylish’));
});&lt;/p&gt;

&lt;p&gt;// configure which files to watch and what tasks to use on file changes
gulp.task(‘watch’, function() {
  gulp.watch(‘source/javascript/&lt;em&gt;*/&lt;/em&gt;.js’, [‘jshint’]);
});
```&lt;/p&gt;

&lt;p&gt;如果你要单独的执行&lt;code class=&quot;highlighter-rouge&quot;&gt;jshint&lt;/code&gt;任务，你可以使用如下命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gulp jshint
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;sass&quot;&gt;编译Sass文件&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://sass-lang.com/&quot;&gt;Sass&lt;/a&gt;是一个常用的CSS预处理语言，它用于增强CSS。我们需要安装&lt;code class=&quot;highlighter-rouge&quot;&gt;gulp-sass&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm install --save-dev gulp-sass
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;任务实现如下：&lt;/p&gt;

&lt;p&gt;```javascript
var gulp   = require(‘gulp’),
    jshint = require(‘gulp-jshint’),
    sass   = require(‘gulp-sass’);&lt;/p&gt;

&lt;p&gt;/* jshint task would be here */&lt;/p&gt;

&lt;p&gt;gulp.task(‘build-css’, function() {
  return gulp.src(‘source/scss/&lt;em&gt;*/&lt;/em&gt;.scss’)
    .pipe(sass())
    .pipe(gulp.dest(‘public/assets/stylesheets’));
});&lt;/p&gt;

&lt;p&gt;/* updated watch task to include sass */&lt;/p&gt;

&lt;p&gt;gulp.task(‘watch’, function() {
  gulp.watch(‘source/javascript/&lt;em&gt;*/&lt;/em&gt;.js’, [‘jshint’]);
  gulp.watch(‘source/scss/&lt;em&gt;*/&lt;/em&gt;.scss’, [‘build-css’]);
});
```&lt;/p&gt;

&lt;p&gt;我们还可以加入&lt;code class=&quot;highlighter-rouge&quot;&gt;gulp-sourcemaps&lt;/code&gt;。Sourcemap是一种用于将处理过的、最小化过的、更改过的文件映射到源文件的强大功能。
支持&lt;code class=&quot;highlighter-rouge&quot;&gt;gulp-sourcemaps&lt;/code&gt;的插件列表可以参考&lt;a href=&quot;https://github.com/floridoo/gulp-sourcemaps/wiki/Plugins-with-gulp-sourcemaps-support&quot;&gt;该链接&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;```javascript
var gulp       = require(‘gulp’),
    jshint     = require(‘gulp-jshint’),
    sass       = require(‘gulp-sass’),
    sourcemaps = require(‘gulp-sourcemaps’);&lt;/p&gt;

&lt;p&gt;gulp.task(‘build-css’, function() {
  return gulp.src(‘source/scss/&lt;em&gt;*/&lt;/em&gt;.scss’)
    .pipe(sourcemaps.init())  // Process the original sources
      .pipe(sass())
    .pipe(sourcemaps.write()) // Add the map to modified source.
    .pipe(gulp.dest(‘public/assets/stylesheets’));
});
```&lt;/p&gt;

&lt;p&gt;如果你使用的是Less，那么可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;gulp-less&lt;/code&gt;插件，使用起来也非常的简单：&lt;/p&gt;

&lt;p&gt;```javascript
var less = require(‘gulp-less’);&lt;/p&gt;

&lt;p&gt;gulp.task(‘less’, function() {
    return gulp.src(‘src/less/*.less’)
        .pipe(less())
        .pipe(gulp.dest(‘src/css’));
});
```&lt;/p&gt;

&lt;h3 id=&quot;javascript&quot;&gt;JavaScript拼接和最小化&lt;/h3&gt;

&lt;p&gt;我们经常需要将多个文件合并在一起，或者是将一个大文件进行最小化（去除其中的空格等），借助gulp我们能够很容易的做到这些。
需要安装如下依赖：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm install --save-dev gulp-concat gulp-uglify
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;任务实现如下:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
gulp.task(&#39;build-js&#39;, function() {
  return gulp.src(&#39;source/javascript/**/*.js&#39;)
    .pipe(sourcemaps.init())
      .pipe(concat(&#39;bundle.js&#39;))
      //only uglify if gulp is ran with &#39;--type production&#39;
      .pipe(gutil.env.type === &#39;production&#39; ? uglify() : gutil.noop()) 
    .pipe(sourcemaps.write())
    .pipe(gulp.dest(&#39;public/assets/javascript&#39;));
});
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;插件&lt;/h2&gt;

&lt;p&gt;Gulp的插件列表你可以使用&lt;a href=&quot;http://gulpjs.com/&quot;&gt;这个工具&lt;/a&gt;进行检索。&lt;/p&gt;

&lt;h3 id=&quot;gulp-load-plugins&quot;&gt;gulp-load-plugins&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/jackfranklin/gulp-load-plugins&quot;&gt;gulp-load-plugins&lt;/a&gt;是一个非常有用的插件，
它能够自动的从&lt;code class=&quot;highlighter-rouge&quot;&gt;package.json&lt;/code&gt;中加载所有的Gulp插件，然后将它们附加到一个对象上。它的用法如下：&lt;/p&gt;

&lt;p&gt;```javascript
var gulp = require(‘gulp’);
var plugins = require(‘gulp-load-plugins’)();&lt;/p&gt;

&lt;p&gt;gulp.task(‘js’, function () {
   return gulp.src(‘js/*.js’)
     .pipe(plugins.jshint())
     .pipe(plugins.jshint.reporter(‘default’))
     .pipe(plugins.uglify())
     .pipe(plugins.concat(‘app.js’))
     .pipe(gulp.dest(‘build’)); 
});
```&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;小结&lt;/h2&gt;

&lt;p&gt;在本文中我们只浅显的探讨了Gulp的使用。Gulp还能够执行很多复杂的任务，因为Gulp依赖于你编写代码来实现这些任务。
例如，我们可以自动化构建项目源文件，实现文件的检查、拼接、最小化，然后在将构建后的项目自动部署到线上。
通过Gulp你能够快速而简单的完成这些任务。有关Gulp的高级用法，你可以参考&lt;a href=&quot;http://csspod.com/advanced-tips-for-using-gulp-js/&quot;&gt;这篇博文&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/lisposter/gulp-docs-zh-cn/blob/master/API.md&quot;&gt;Gulp API Docs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://gulpjs.com/&quot;&gt;Gulp Website&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://scotch.io/tutorials/automate-your-tasks-easily-with-gulp-js&quot;&gt;Gulp tutorial&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://zinoui.com/blog/task-automation-with-gulp-js&quot;&gt;Another Gulp tutorial&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://nodejs.org/dist/latest-v4.x/docs/api/stream.html#stream_stream&quot;&gt;Node.js API: Stream&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 26 Feb 2016 00:00:00 +0800</pubDate>
        <link>twolun.github.com/posts/using-gulp-to-automate-your-tasks.html</link>
        <guid isPermaLink="true">twolun.github.com/posts/using-gulp-to-automate-your-tasks.html</guid>
        
        
        <category>knowledge</category>
        
      </item>
    
      <item>
        <title>JavaScript Promise API</title>
        <description>&lt;p&gt;Promise是抽象异步处理对象以及对其进行各种操作的组件。
本文将会详细的向你介绍如何在JavaScript中借助Promise来简化异步代码流。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;statement&quot;&gt;Statement&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;作者：&lt;/strong&gt; &lt;a href=&quot;http://wwsun.github.com&quot;&gt;景庄&lt;/a&gt;，Web开发者，主要关注JavaScript、Node.js、React、Docker等。&lt;/li&gt;
  &lt;li&gt;本文是&lt;a href=&quot;http://www.html5rocks.com/en/tutorials/es6/promises/&quot;&gt;JavaScript Promise - there and back again&lt;/a&gt;改动版&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;背景知识&lt;/h2&gt;

&lt;p&gt;JavaScript是单线程的，这意味着代码是按顺序执行的。对于浏览器而言，JavaScript代码和其他任务共享一个线程，
不同的浏览器略有差异，但大体上这些和JavaScript共享线程的任务主要包括重绘、更新样式、用户交互等，
所有这些任务操作都会阻塞其他任务。&lt;/p&gt;

&lt;p&gt;避免事件阻塞的常用方法是使用事件监听器。我们可以为某些特定事件设置监听器，如果事件发生的话，便立刻触发监听器，
你应该已经习惯使用回调函数来解决这个问题了，例如：&lt;/p&gt;

&lt;p&gt;```javascript
var img1 = document.querySelector(‘.img-1’);
img1.addEventListener(‘load’, function() {
  // 图片加载完成
});&lt;/p&gt;

&lt;p&gt;img1.addEventListener(‘error’, function() {
  // 出问题了
});
```&lt;/p&gt;

&lt;p&gt;上面的代码中，我们添加了两个监听器，请求图片，回调函数只在事件发生的时候才会被触发。但是通过事件机制还存在几个问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;事件在绑定之前就发生了怎么办？&lt;/li&gt;
  &lt;li&gt;在添加监听器之前，图片加载发生了错误怎么办？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;仅仅是一张图片就存在这么多问题，那么如果有一堆图片要处理，又该怎么办？下面我们就谈谈Promise，一个越来越流行的异步解决方案。&lt;/p&gt;

&lt;h2 id=&quot;promise&quot;&gt;Promise&lt;/h2&gt;

&lt;p&gt;JavaScript的一大特点就是会涉及到大量的异步代码。同步代码通常易于理解和调试，而异步代码则具有更好的性能和灵活性。
目前Promise正逐渐称为JavaScript世界的一个重要组成部分，并且很多新的API也都基于Promise进行了实现。
目前已经有一些原生API使用了Promise，包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://davidwalsh.name/javascript-battery-api&quot;&gt;Battery API&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://davidwalsh.name/fetch&quot;&gt;Fetch API&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;ServiceWorker API&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;promise-1&quot;&gt;什么是Promise&lt;/h3&gt;

&lt;p&gt;那么到底什么是Promise呢？&lt;code class=&quot;highlighter-rouge&quot;&gt;Promise&lt;/code&gt;是ES6规范新增的对象，它可以用于延迟计算和异步计算。
一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Promise&lt;/code&gt;对象代表着一个还未完成，但预期会完成的操作。需要记住：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个Promise要么成功要么失败，并且状态不可变&lt;/li&gt;
  &lt;li&gt;可以根据Promise的结果设置特定的回调函数&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;promise-2&quot;&gt;Promise的状态&lt;/h3&gt;

&lt;p&gt;一个Promise的状态可以是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;等待 pending&lt;/strong&gt; - Promise的初始化状态，等待结果&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;完成 fullfilled&lt;/strong&gt; - 该Promise对应的异步操作成功完成了&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;失败 rejected&lt;/strong&gt; - 该Promise对应的异步操作失败了&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;结束 settled&lt;/strong&gt; - 任务完成或失败了&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;基本使用&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;new Promise()&lt;/code&gt;构造器应该只被用于传统的异步任务上，例如&lt;code class=&quot;highlighter-rouge&quot;&gt;setTimeout&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLHttpRequest&lt;/code&gt;。
通过&lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt;关键字创建一个新的&lt;code class=&quot;highlighter-rouge&quot;&gt;Promise&lt;/code&gt;，它接收一个回调函数作为参数，该回调函数又包括了两个特定的回调函数，
分别被命名为&lt;code class=&quot;highlighter-rouge&quot;&gt;resolve&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;reject&lt;/code&gt;，成功后调用&lt;code class=&quot;highlighter-rouge&quot;&gt;resolve&lt;/code&gt;，失败则调用&lt;code class=&quot;highlighter-rouge&quot;&gt;reject&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;根据不同的任务，由开发者来决定&lt;code class=&quot;highlighter-rouge&quot;&gt;resolve&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;reject&lt;/code&gt;在函数体内的位置。&lt;/p&gt;

&lt;p&gt;```javascript
let p = new Promise(function(resolve, reject) {
  // 执行异步任务
  if(/* good condition */) {
    resolve(‘Success’);
  } else {
    // 传递Error对象的好处是可以包含调用堆栈，便于调试
    reject(Error(‘Failure’));
  }
});&lt;/p&gt;

&lt;p&gt;p.then(function(result) {
  // do something with the reuslt
  foo(result);
}， function(err){
  console.error(err);
});
```&lt;/p&gt;

&lt;p&gt;使用Promise则非常的简单，可以调用&lt;code class=&quot;highlighter-rouge&quot;&gt;Promise&lt;/code&gt;对象的&lt;code class=&quot;highlighter-rouge&quot;&gt;then()&lt;/code&gt;方法来处理异步计算的结果。&lt;code class=&quot;highlighter-rouge&quot;&gt;then&lt;/code&gt;接收两个回调函数，
分别是成功的回调函数和失败时的回调函数，这两个参数都是可选的。&lt;/p&gt;

&lt;p&gt;Promise的使用有两点需要记住的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;then()&lt;/code&gt;方法可以链式调用&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;catch()&lt;/code&gt;方法可以作为错误处理语句的语法糖，相当于&lt;code class=&quot;highlighter-rouge&quot;&gt;then(undefined, function(error) { ... });&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在具体讲解这两点之前，我们先来看一个例子。下面这个例子用于将&lt;code class=&quot;highlighter-rouge&quot;&gt;XMLHttpRequest&lt;/code&gt;转换为一个基于Promise的接口。
我们以GET请求为例：&lt;/p&gt;

&lt;p&gt;```javascript
function get(url) {
  // 返回一个新的 Promise
  return new Promise(function(resolve, reject) {
    // 经典 XHR 操作
    var req = new XMLHttpRequest();
    req.open(‘GET’, url);&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;req.onload = function() {
  // 当发生 404 等状况的时候调用此函数
  // 所以先检查状态码
  if (req.status == 200) {
    // 以响应文本为结果，完成此 Promise
    resolve(req.response);
  }
  else {
    // 否则就以状态码为结果否定掉此 Promise
    // （提供一个有意义的 Error 对象）
    reject(Error(req.statusText));
  }
};

// 网络异常的处理方法
req.onerror = function() {
  reject(Error(&quot;Network Error&quot;));
};

// 发出请求
req.send();   }); } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们现在可以这么调用它：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
get(&#39;story.json&#39;).then(function(response) {
  console.log(&quot;Success!&quot;, response);
}, function(error) {
  console.error(&quot;Failed!&quot;, error);
});
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;现在我们发起XHR请求便变得简单直观的多了。&lt;code class=&quot;highlighter-rouge&quot;&gt;story.json&lt;/code&gt;文件的内容如下：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;json
{
  &quot;heading&quot;: &quot;&amp;lt;h1&amp;gt;A story about something&amp;lt;/h1&amp;gt;&quot;,
  &quot;chapterUrls&quot;: [
    &quot;chapter-1.json&quot;,
    &quot;chapter-2.json&quot;,
    &quot;chapter-3.json&quot;,
    &quot;chapter-4.json&quot;,
    &quot;chapter-5.json&quot;
  ]
}
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;promiseresolve&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Promise.resolve&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;有时你无需在promise内完成一个异步任务——如果一个异步动作被执行是可能的话，然而，返回一个Promise是将是最合适的，
因此你可以总是期望从给定函数中产生的promise。在这种情况下，你可以简单的调用&lt;code class=&quot;highlighter-rouge&quot;&gt;Promise.resolve()&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;Promise.reject()&lt;/code&gt;，
而无需&lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt;关键字。例如：&lt;/p&gt;

&lt;p&gt;```javascript
var userCache = {};
function getUserDetail(username) {
  // 两种情况下，要么缓存要么不缓存，都将返回一个promise&lt;/p&gt;

&lt;p&gt;if (userCache[username]) {
    // 不使用new关键字返回一个promise
    return Promise.resolve(userCache[username]);
  }&lt;/p&gt;

&lt;p&gt;// 使用fetch API获取信息
  // fetch返回一个promise
  return fetch(‘user/’ + username + ‘.json’)
    .then(result =&amp;gt; {
      userCache[username] = result;
      return result;
    })
    .catch(() =&amp;gt; {
      throw new Error(‘Could not find user: ‘ + username);
    });
}
```&lt;/p&gt;

&lt;p&gt;由于返回的是一个Promise，你可以在返回值上使用&lt;code class=&quot;highlighter-rouge&quot;&gt;then&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;catch&lt;/code&gt;方法。
可以将&lt;code class=&quot;highlighter-rouge&quot;&gt;Promise.resolve&lt;/code&gt;看作是&lt;code class=&quot;highlighter-rouge&quot;&gt;new Promise()&lt;/code&gt;的快捷方式。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;链式调用&lt;/h3&gt;

&lt;p&gt;上面我们说过&lt;code class=&quot;highlighter-rouge&quot;&gt;then()&lt;/code&gt;接收两个参数，分别对应成功和失败时的回调函数。我们还可以将多个&lt;code class=&quot;highlighter-rouge&quot;&gt;then&lt;/code&gt;方法串联起来，
用于修改结果或执行更多的异步操作。&lt;/p&gt;

&lt;p&gt;你可以对结果进行修改，然后返回一个新的值，例如：&lt;/p&gt;

&lt;p&gt;```javascript
new Promise(function(resolve, reject) { 
	// A mock async action using setTimeout
	setTimeout(function() { resolve(10); }, 3000);
})
.then(num =&amp;gt; { console.log(‘first then: ‘, num); return num * 2; })
.then(num =&amp;gt; { console.log(‘second then: ‘, num); return num * 2; })
.then(num =&amp;gt; { console.log(‘last then: ‘, num);});&lt;/p&gt;

&lt;p&gt;// From the console:
// first then:  10
// second then:  20
// last then:  40
```&lt;/p&gt;

&lt;p&gt;每个&lt;code class=&quot;highlighter-rouge&quot;&gt;then&lt;/code&gt;接收前一个&lt;code class=&quot;highlighter-rouge&quot;&gt;then&lt;/code&gt;的返回值的结果。&lt;/p&gt;

&lt;p&gt;回到之前的&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;函数，我们可以修改返回值的类型，将结果进行一定的转换：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
get(&#39;story.json&#39;).then(function(response) {
  return JSON.parse(response);
}).then(function(response) {
  console.log(&quot;Yey JSON!&quot;, response);
});
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;为了让代码变得更简单，可以再次进行改进：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;因为&lt;code class=&quot;highlighter-rouge&quot;&gt;JSON.parse&lt;/code&gt;只接收一个参数，并返回转换后的结果，我们可以直接使用&lt;code class=&quot;highlighter-rouge&quot;&gt;then(JSON.parse)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;then&lt;/code&gt;中的回调函数，我们可以直接使用ES6的胖箭头函数，这样可以让代码更直观&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
get(&#39;story.json&#39;).then(JSON.parse).then(response =&amp;gt; console.log(&quot;JSON data: &quot;, response);
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;由于这段代码会被重复调用，我们可以定义一个新的&lt;code class=&quot;highlighter-rouge&quot;&gt;getJSON&lt;/code&gt;函数：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
function getJSON(url) {
  return get(url).then(JSON.parse);  // 返回一个获取JSON并加以解析的Promise
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;对于串联起来的&lt;code class=&quot;highlighter-rouge&quot;&gt;then()&lt;/code&gt;方法而言：如果你返回了一个值，那么它就会被传给下一个&lt;code class=&quot;highlighter-rouge&quot;&gt;then()&lt;/code&gt;的回调。
如果你返回一个“类Promise”对象，则下一个&lt;code class=&quot;highlighter-rouge&quot;&gt;then()&lt;/code&gt;就会等待这个Promise明确结束（成功/失败）才会执行。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
getJSON(&#39;story.json&#39;)
  .then(story =&amp;gt; getJSON(story.chapterUrls[0]))
  .then(chapter =&amp;gt; console.log(&quot;Got chapter 1!, &quot; chapter));
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在上面的代码中，我们首先发起对&lt;code class=&quot;highlighter-rouge&quot;&gt;story.json&lt;/code&gt;的异步请求，它会返回给我们一个URL列表，然后我们请求其中的第一个，。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;错误处理&lt;/h3&gt;

&lt;p&gt;前面我们已经知道，&lt;code class=&quot;highlighter-rouge&quot;&gt;then&lt;/code&gt;接收两个参数，一个处理成功时的回调函数，一个处理失败时的回调函数。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
get(&#39;story.json&#39;).then(function(response) {
  console.log(&quot;Success!&quot;, response);
}, function(error) {
  console.log(&quot;Failed!&quot;, error);
});
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;你还可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;catch&lt;/code&gt;来进行错误处理，实际上，它不过是&lt;code class=&quot;highlighter-rouge&quot;&gt;then(undefined, func)&lt;/code&gt;的语法糖而已。这样能够让代码更直观：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
get(&#39;story.json&#39;)
  .then(response =&amp;gt; console.log(&#39;Success!&#39;, response))
  .catch(error =&amp;gt; console.error(&#39;Failed!&#39;, error));
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;并行和串行&lt;/h2&gt;

&lt;p&gt;异步意味着你不用等待前一件事情做完就可以做后一件事。现在，我们想要遍历所有章节的URL并且依次请求，应该怎么办？
使用传统的方法，你可能会想到&lt;code class=&quot;highlighter-rouge&quot;&gt;array.forEach&lt;/code&gt;：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
story.chapterUrls.forEach(chapterUrl =&amp;gt; {
  // getJSON是异步操作
  getJSON(chapterUrl).then(chapter =&amp;gt; { 
    addHtmlToPage(chapter.html)
  });
});
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;但是这么做并不可行，因为&lt;code class=&quot;highlighter-rouge&quot;&gt;forEach&lt;/code&gt;并&lt;strong&gt;不支持异步操作&lt;/strong&gt;！&lt;/p&gt;

&lt;h3 id=&quot;promise-3&quot;&gt;Promise序列&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
// 遍历所有章节的 url
story.chapterUrls.reduce(function(sequence, chapterUrl) {
  // 从 sequence 开始把操作接龙起来
  return sequence.then(() =&amp;gt; getJSON(chapterUrl))
    .then(chapter =&amp;gt; { 
      addHtmlToPage(chapter.html) ;
    });
}, Promise.resolve());
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;上面的代码中使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;Promise.resolve()&lt;/code&gt;，它会依据你传入的任何值返回一个Promise。
如果你传给它一个类Promise对象（带有&lt;code class=&quot;highlighter-rouge&quot;&gt;then&lt;/code&gt;方法），它会生成一个带有同样肯定/否定回调的Promsie。
如果你传给它任何别的值，如&lt;code class=&quot;highlighter-rouge&quot;&gt;Promise.resolve(&#39;hello&#39;)&lt;/code&gt;，它会创建一个以该值为完成结果的&lt;code class=&quot;highlighter-rouge&quot;&gt;Promise&lt;/code&gt;，
如过不传入任何值，则以&lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;为完成结果。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;reduce&lt;/code&gt;回调会一次应用在每一个数组元素上，第一轮的&lt;code class=&quot;highlighter-rouge&quot;&gt;sequence&lt;/code&gt;是&lt;code class=&quot;highlighter-rouge&quot;&gt;Promise.resolve()&lt;/code&gt;，
之后的调用里&lt;code class=&quot;highlighter-rouge&quot;&gt;sequence&lt;/code&gt;就是上次函数执行的结果。&lt;code class=&quot;highlighter-rouge&quot;&gt;reduce()&lt;/code&gt;方法非常适合用于把一个值归并处理为一个值。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Array.prototype.reduce(callback, [initialValue])&lt;/code&gt;方法接收一个函数作为累加器，数组中的每个值（从左到右）开始合并，
最终为一个值。参数二作为第一次调用callback的第一个参数。此外，callback包括四个参数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;previousValue - 上一次调用回调返回的值，或者是提供的初始值（initialValue）&lt;/li&gt;
  &lt;li&gt;currentValue - 数组中当前被处理的元素&lt;/li&gt;
  &lt;li&gt;index - 当前元素在数组中的索引&lt;/li&gt;
  &lt;li&gt;array - 调用reduce的数组&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;汇总前面的代码为：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
getJSON(&#39;story.json&#39;)
  .then(story =&amp;gt; {
    addHtmlToPage(story.heading);
    return story.chapterUrls.reduce((sequence, chapterUrl) =&amp;gt; {
      return sequence.then(() =&amp;gt; getJSON(chapterUrl))
      .then(chapter =&amp;gt; addHtmlToPage(chapter.html));
    }, Promise.resolve());
  })
  .then(() =&amp;gt; addTextToPage(&#39;All done&#39;))
  .catch(err =&amp;gt; addTextToPage(&#39;Argh, broken: &#39; + err.message))
  .then(() =&amp;gt; document.querySelector(&#39;.spinner&#39;).style.display = &#39;none&#39;);
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;辅助方法定义如下：&lt;/p&gt;

&lt;p&gt;```javascript
var storyDiv = document.querySelector(‘.story’);&lt;/p&gt;

&lt;p&gt;function addHtmlToPage (html) {
  var div = document.createElement(‘div’);
  div.innerHTML = html;
  storyDiv.appendChild(div);
}&lt;/p&gt;

&lt;p&gt;function addTextToPage (text) {
  var p = document.createElement(‘p’);
  p.textContent = text;
  storyDiv.appendChild(p);
}
```&lt;/p&gt;

&lt;h3 id=&quot;promiseall&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Promise.all&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;浏览器很擅长同时加载多个文件，上面的方法属于一个接一个下载章节，这先得非常的低效。我们希望同时下载所有章节，
全部完成后一次搞定，正好就有这么个API：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
Promise.all(arrayOfPromise).then(arrayOfResults =&amp;gt; {} );
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Promise.all&lt;/code&gt;接收一个Promise数组作为参数，创建一个当所有Promise都完成之后就完成的Promise，它的完成结果是一个数组，
包含了所有先前传入的那些Promise的完成结果，顺序和将它们传入的数组顺序一致。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
getJSON(&#39;story.json&#39;).then(story =&amp;gt; {
  addHtmlToPage(story.heading);
  // 接收一个Promise数组并等待他们全部结束
  // 把章节URL数组转换成对应的Promise数组
  return Promise.all(story.chapterUrls.map(getJSON));
}).then(chapters =&amp;gt; {
  // 现在我们有了顺序的章节JSON，遍历它们
  // 并添加到页面中
  chapters.forEach(chapter =&amp;gt; addHtmlToPage(chapter.html));
  addTextToPage(&#39;All done&#39;);
})
  // 捕获过程中的任何错误
  .catch(err =&amp;gt; addTextToPage(&#39;Argh, broken: &#39; + err.message))
  .then(() =&amp;gt; document.querySelector(&#39;.spinner&#39;).style.display = &#39;none&#39;);
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;根据连接状况，改进的代码会比顺序加载方式提速数秒，甚至代码行数也更少。章节加载完成的顺序不确定，
但它们显示在页面上的顺序准确无误。&lt;/p&gt;

&lt;p&gt;但仍然有改进空间：第一章内容加载完成后，我们向让它立即填进页面，这样用户可以在其他加载任务尚未完成之前就开始阅读。
当第三章到达的时候我们不动声色，第二章也到达之后我们再把第二章和第三章内容填入页面，以此类推。&lt;/p&gt;

&lt;p&gt;为了达到这个效果，我们同时请求所有的章节内容，然后创建一个序列依次将其填入页面：&lt;/p&gt;

&lt;p&gt;```javascript
getJSON(‘story.json’)
  .then(story =&amp;gt; {
    addHtmlToPage(story.heading);&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 把章节 URL 数组转换成对应的 Promise 数组
// 这样就可以并行加载它们
return story.chapterUrls.map(getJSON)
  .reduce((sequence, chapterPromise) =&amp;gt; {

    // 使用 reduce 把这些 Promise 接龙
    // 以及将章节内容添加到页面
    return sequence

      // 等待当前 sequence 中所有章节和本章节的数据到达
      .then(() =&amp;gt; chapterPromise)
      .then(chapter =&amp;gt; { addHtmlToPage(chapter.html) });
  }, Promise.resolve());   })   .then(() =&amp;gt; { addTextToPage(&quot;All done&quot;) })   // 捕获过程中的任何错误   .catch(err =&amp;gt; { addTextToPage(&quot;Argh, broken: &quot; + err.message) })   .then(() =&amp;gt; { document.querySelector(&#39;.spinner&#39;).style.display = &#39;none&#39; }); ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://davidwalsh.name/promises&quot;&gt;JavaScript Promise API&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.html5rocks.com/zh/tutorials/es6/promises&quot;&gt;JavaScript Promise: There and Back Again&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://liubin.org/promises-book/&quot;&gt;Promise迷你书&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;MDN: Promise&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 24 Feb 2016 00:00:00 +0800</pubDate>
        <link>twolun.github.com/posts/javascript-promise-api.html</link>
        <guid isPermaLink="true">twolun.github.com/posts/javascript-promise-api.html</guid>
        
        
        <category>knowledge</category>
        
      </item>
    
      <item>
        <title>call()、apply()、bind()的用法</title>
        <description>&lt;p&gt;JavaScript中的函数不仅是一种类似于Java中方法的语言功能，它还可以作为对象而存在。
本文将要探讨JavaScript中函数的一些特殊用法，包括&lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;apply&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;bind&lt;/code&gt;三个原型方法。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;statement&quot;&gt;Statement&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;作者：&lt;/strong&gt; &lt;a href=&quot;http://wwsun.github.com&quot;&gt;景庄&lt;/a&gt;，Web开发者，主要关注JavaScript、Node.js、React、Docker等。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;函数基础&lt;/h2&gt;

&lt;p&gt;JavaScript中的函数是一种类似于Java中方法的语言功能，不过它可以独立于类进行定义。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;函数式编程：&lt;/strong&gt; 由于JavaScript支持匿名函数，因此可以将函数作为对象来使用，
所以JavaScript不仅支持过程式编程（面向对象也是过程式编程的一种），还支持函数式编程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;上下文&lt;/h3&gt;

&lt;p&gt;函数的每次&lt;strong&gt;调用&lt;/strong&gt;都会拥有一个特殊值——本次调用的上下文（context）——这就是&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;关键字的值。
如果函数挂载在一个对象上，作为对象的一个属性，就称它为对象的方法。当通过这个对象来调用函数时，该对象就是此次调用的上下文，
也就是该函数的&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;的值。&lt;/p&gt;

&lt;p&gt;需要注意，&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;是一个关键字，不是变量，也不是属性名。JavaScript的语法不允许给&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;赋值。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;函数是一种对象&lt;/h3&gt;

&lt;p&gt;JavaScript中的函数和Java中的方法或C语言中的函数最大不同在于，JavaScript中的函数也是一种对象。
但这并不意味着，所有的对象都是函数。函数是一种包含了可执行代码，并能够被其他代码调用的特殊的对象。&lt;/p&gt;

&lt;p&gt;和变量不同，关键字&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;没有作用域的限制，嵌套的函数不会从调用它的函数中继承&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;。
- 如果嵌套函数作为方法调用，其&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;的值指向调用它的对象。
- 如果嵌套函数作为函数调用，其&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;的值不是全局对象（非严格模式下）就是&lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;（严格模式下）。&lt;/p&gt;

&lt;p&gt;很多人误以为调用嵌套函数时&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;会指向掉i用外层函数的上下文。如果你想访问这个外部函数的&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;值，
需要将&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;的值保存都在一个变量中，这个变量和内部函数都同在一个作用域内。例如：&lt;/p&gt;

&lt;p&gt;```javascript
var o = {
  m: function() {
    var self = this;
    console.log(this==o); // true
    f();&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function f() {
  console.log(this === o); // false，this的值是全局对象或undefined
  console.log(self === o); // true
}   } } ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-3&quot;&gt;闭包&lt;/h3&gt;

&lt;p&gt;JavaScript的函数可以嵌套在其他函数中定义，这样它们就可以访问它们被定义时所处的作用域中的任何变量。
这意味着JavaScript函数构成了一个闭包（closure），它给JavaScript带来了非常强劲的编程能力。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;作为值的函数&lt;/h2&gt;

&lt;p&gt;在JavaScript中，函数不仅是一种语法，也是值，也就是说，可以将函数赋值给变量，存储在对象的属性或数组的元素中，
作为参数传入另外一个函数等。&lt;/p&gt;

&lt;h2 id=&quot;bindcallapply&quot;&gt;bind、call、apply&lt;/h2&gt;

&lt;p&gt;每一个函数都包含一个&lt;code class=&quot;highlighter-rouge&quot;&gt;prototype&lt;/code&gt;属性，这个属性是指向一个对象的引用，这个对象称作“原型对象”。
每一个函数都包含不同的原型对象。当将函数用作构造函数的时候，新创建的对象会从原型对象上继承属性。&lt;/p&gt;

&lt;h3 id=&quot;functionprototypecallfunctionprototypeapply&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Function.prototype.call()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Function.prototype.apply()&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;call()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;apply()&lt;/code&gt;可以看作为某个对象的方法，通过调用方法的形式来间接调用函数。
它们的第一个参数是要调用函数的母对象，它是调用上下文，在函数体内通过&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;来获得对它的引用。
&lt;code class=&quot;highlighter-rouge&quot;&gt;apply()&lt;/code&gt;方法和&lt;code class=&quot;highlighter-rouge&quot;&gt;call()&lt;/code&gt;方法的作用相同，只不过函数传递的方式不一样，它的实参都放入在一个数组中。&lt;/p&gt;

&lt;p&gt;举个例子，&lt;strong&gt;以对象o的方法的形式调用函数f()，并传入两个参数&lt;/strong&gt;，可以使用这样的代码：&lt;/p&gt;

&lt;p&gt;```javascript&lt;/p&gt;

&lt;p&gt;var o = {};&lt;/p&gt;

&lt;p&gt;function f(a, b) {
  return a + b;
}&lt;/p&gt;

&lt;p&gt;f.call(o, 1, 2);        // 将函数f作为o的方法，实际上就是重新设置函数f的上下文
f.apply(o, [1, 2]);
```&lt;/p&gt;

&lt;p&gt;再举一个来自MDN的&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call&quot;&gt;例子&lt;/a&gt;，
&lt;strong&gt;使用call方法调用匿名函数&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;在下例中的for循环体内，我们创建了一个匿名函数，然后通过调用该函数的call方法，将每个数组元素作为指定的this值执行了那个匿名函数。
这个匿名函数的主要目的是给每个数组元素对象添加一个print方法，这个print方法可以打印出各元素在数组中的正确索引号。
当然，这里不是必须得让数组元素作为this值传入那个匿名函数（普通参数就可以），目的是为了演示call的用法。&lt;/p&gt;

&lt;p&gt;```javascript
var animals = [
  {species: ‘Lion’, name: ‘King’},
  {species: ‘Whale’, name: ‘Fail’}
];&lt;/p&gt;

&lt;p&gt;for (var i = 0; i &amp;lt; animals.length; i++) {
  (function (i) { 
    this.print = function () { 
      console.log(‘#’ + i  + ‘ ‘ + this.species + ‘: ‘ + this.name); 
    } 
    this.print();
  }).call(animals[i], i);
}
```&lt;/p&gt;

&lt;h3 id=&quot;functionprototypebind&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Function.prototype.bind()&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bind()&lt;/code&gt;是在ES5中新增的方法，从名字可以看出，这个方法的主要作用就是将函数绑定到某个对象。
当在函数&lt;code class=&quot;highlighter-rouge&quot;&gt;f()&lt;/code&gt;上调用&lt;code class=&quot;highlighter-rouge&quot;&gt;bind()&lt;/code&gt;方法并后窜入一个对象&lt;code class=&quot;highlighter-rouge&quot;&gt;o&lt;/code&gt;作为参数，这个方法将返回一个新函数：
（以函数调用的方式）调用新的函数将会把原始的函数&lt;code class=&quot;highlighter-rouge&quot;&gt;f()&lt;/code&gt;作为&lt;code class=&quot;highlighter-rouge&quot;&gt;o&lt;/code&gt;的方法来调用。例如：&lt;/p&gt;

&lt;p&gt;```javascript
function f(y) {
  return this.x + y;
}&lt;/p&gt;

&lt;p&gt;var o = {
  x: 1
};&lt;/p&gt;

&lt;p&gt;var g = f.bind(o);  // 通过调用 g(x) 来调用 o.f(x)
g(2); // 3
```&lt;/p&gt;

&lt;p&gt;其实我们可以轻松的实现&lt;code class=&quot;highlighter-rouge&quot;&gt;bind()&lt;/code&gt;方法：&lt;/p&gt;

&lt;p&gt;```javascript
// 返回一个函数，通过调用它来调用o中的方法f()，传递它所有的实参
function bind(f, o) {
  if (f.bind) return f.bind(o); // 如果bind()方法存在，使用bind()方法
  else return function () {
    return f.apply(o, arguments);
  }
}&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;函数式编程&lt;/h2&gt;

&lt;p&gt;JavaScript并非函数式编程语言，但在JavaScript中可以像操控对象一样操控函数，也就是说可以在JavaScript中应用函数式编程技术。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;使用函数处理数组&lt;/h3&gt;

&lt;p&gt;假设有一个数组，数组元素都是数字，我们想要计算这些元素的平均值和标准差。&lt;/p&gt;

&lt;p&gt;```javascript
var data = [1, 1, 3, 5, 5];
var sum = function(x, y) {
  return x + y;
};
var square = function(x) {
  return x * x;
};&lt;/p&gt;

&lt;p&gt;var mean = data.reduce(sum)/data.length;
var deviations = data.map(x =&amp;gt; x - mean);
var stddev = Math.sqrt(deviations.map(square).reduce(sum)/(data.length - 1));
```&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;高阶函数&lt;/h3&gt;

&lt;p&gt;高阶函数就是操作函数的函数，它接收一个或多个函数作为参数，并返回一个新函数。举个例子：&lt;/p&gt;

&lt;p&gt;```javascript
function not(f) {
  return function () {
    var result = f.apply(this, arguments);
    return !result;
  };
}&lt;/p&gt;

&lt;p&gt;// 判断x是否为偶数的函数
var even = function(x) {
  return x % 2 === 0;
};&lt;/p&gt;

&lt;p&gt;var odd = not(even);            // 一个新函数，所做的事情和even()相反
[1, 1, 3, 5, 5].every(odd);     // true，每个函数都是奇数&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;函数&lt;code class=&quot;highlighter-rouge&quot;&gt;not()&lt;/code&gt;是个高阶函数，因为它返回一个新的函数，这个新函数将它的实参传入&lt;code class=&quot;highlighter-rouge&quot;&gt;f()&lt;/code&gt;，并返回&lt;code class=&quot;highlighter-rouge&quot;&gt;f&lt;/code&gt;的返回值的逻辑非。&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call&quot;&gt;Function.prototype.call()&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 18 Feb 2016 00:00:00 +0800</pubDate>
        <link>twolun.github.com/posts/javascript-functions.html</link>
        <guid isPermaLink="true">twolun.github.com/posts/javascript-functions.html</guid>
        
        
        <category>knowledge</category>
        
      </item>
    
      <item>
        <title>使用ES6编写React应用（4）：使用高阶组件替代Mixins</title>
        <description>&lt;p&gt;本文是使用ES6编写React应用的第4篇，我们将主要讨论如何使用高阶组件的方式取代传统的React Mixins。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;statement&quot;&gt;Statement&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;作者：&lt;/strong&gt; &lt;a href=&quot;http://wwsun.github.com&quot;&gt;景庄&lt;/a&gt;，Web开发者，主要关注JavaScript、Node.js、React、Docker等。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;源码：&lt;/strong&gt; 本文的源代码地址：https://github.com/wwsun/react-es6-tutorial&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;介绍&lt;/h2&gt;

&lt;p&gt;当使用&lt;code class=&quot;highlighter-rouge&quot;&gt;React.createClass()&lt;/code&gt;的时候，你可能会使用到所谓的Mixins。使用Mixins允许我们在我们的React组件中混入一些附加的功能。
这个概念并不是React所独有的，它也存在于普通的JS或其他语言的框架中。&lt;/p&gt;

&lt;p&gt;如果是要使用ES6来编写React组件的话，我们将不建议你使用React的mixin机制了。
本文并不会深入的探讨为什么不建议使用mixin的原因。如果你感兴趣的话，你可以通过如下的链接查看相关的资料：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://facebook.github.io/react/blog/2015/01/27/react-v0.13.0-beta-1.html#mixins&quot;&gt;React官方有关在ES6中使用mixins的博文&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750&quot;&gt;Mixins已死——Dan Abramov&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面我们将主要关注的是具体的例子。&lt;/p&gt;

&lt;h2 id=&quot;mixins&quot;&gt;使用高阶组件替代Mixins&lt;/h2&gt;

&lt;p&gt;本文我们将继续使用之前的代码，并对代码做一定的修改。通过本文，我们将能够在页面中显示用户在当前页面停留的时间。&lt;/p&gt;

&lt;p&gt;为什么能够更好的进行说明，我们将不会修改&lt;code class=&quot;highlighter-rouge&quot;&gt;CartItem&lt;/code&gt;组件的代码。而是通过提供一些能够包裹&lt;code class=&quot;highlighter-rouge&quot;&gt;CartItem&lt;/code&gt;组件的组件，
并通过一些额外的功能来“增强”&lt;code class=&quot;highlighter-rouge&quot;&gt;CartItem&lt;/code&gt;组件。这样的组件我们称之为高阶组件（Higher-Order Component）。&lt;/p&gt;

&lt;p&gt;这个概念听起来可能有点含义模糊，随着我们的深入，你将会理解的更透彻一点。&lt;/p&gt;

&lt;p&gt;假设，我们有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;IntervalEnhance&lt;/code&gt;组件，我们在&lt;code class=&quot;highlighter-rouge&quot;&gt;CartItem&lt;/code&gt;组件中导入它，并通过它来包裹原有的导出对象。&lt;/p&gt;

&lt;p&gt;```javascript
// src/components/cart-item.jsx
import React from ‘react’;
import { IntervalEnhance } from “./interval-enhance.jsx”; // 1. 导入包裹组件&lt;/p&gt;

&lt;p&gt;class CartItem extends React.Component {
  // component code here
}&lt;/p&gt;

&lt;p&gt;export default IntervalEnhance(CartItem); // 2. 包裹原有的CartItem组件
```&lt;/p&gt;

&lt;p&gt;现在我们将来编写这个&lt;code class=&quot;highlighter-rouge&quot;&gt;IntervalEnhance&lt;/code&gt;组件。&lt;/p&gt;

&lt;p&gt;```javascript
// src/components/interval-enhance.jsx
import React from ‘react’;&lt;/p&gt;

&lt;p&gt;// 1
export let IntervalEnhance = ComponsedComponent =&amp;gt; class extends React.Component {&lt;/p&gt;

&lt;p&gt;constructor(props) {
    super(props);
    this.state = {
      seconds: 0 // 2
    };
  }&lt;/p&gt;

&lt;p&gt;// 3
  componentDidMount() {
    this.interval = setInterval(this.tick.bind(this), 1000);
  }&lt;/p&gt;

&lt;p&gt;// 3
  componentWillUnmount() {
    clearInterval(this.interval);
  }&lt;/p&gt;

&lt;p&gt;tick() {
    this.setState({
      seconds: this.state.seconds + 1000
    });
  }&lt;/p&gt;

&lt;p&gt;render() {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 4
return &amp;lt;ComponsedComponent {...this.props} {...this.state} /&amp;gt;;   } }; ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们一一的来解释上面几处加注释的代码：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ComposedComponent =&amp;gt; class extends React.Component&lt;/code&gt; - 这其实和定义返回类的函数一样。
其中&lt;code class=&quot;highlighter-rouge&quot;&gt;ComposedComponent&lt;/code&gt;是我们想要“增强”的组件（在上面的代码中就是&lt;code class=&quot;highlighter-rouge&quot;&gt;CartItem&lt;/code&gt;组件）。
通过使用&lt;code class=&quot;highlighter-rouge&quot;&gt;export let IntervalEnhance&lt;/code&gt;我们可以导出整个函数为&lt;code class=&quot;highlighter-rouge&quot;&gt;IntervalEnhance&lt;/code&gt;（也就是上面代码中的&lt;code class=&quot;highlighter-rouge&quot;&gt;CartItem&lt;/code&gt;）。&lt;/li&gt;
  &lt;li&gt;初始化组件的状态（state），设置&lt;code class=&quot;highlighter-rouge&quot;&gt;seconds&lt;/code&gt;的值为0。&lt;/li&gt;
  &lt;li&gt;组件的生命周期钩子函数，用于期待能够和暂停计数器。&lt;/li&gt;
  &lt;li&gt;最重要的一个部分。这行代码将所有的&lt;code class=&quot;highlighter-rouge&quot;&gt;state&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;props&lt;/code&gt;拿到我们的“增强器”组件中，然后转移到&lt;code class=&quot;highlighter-rouge&quot;&gt;CartItem&lt;/code&gt;组件中。
通过这种方式，&lt;code class=&quot;highlighter-rouge&quot;&gt;CartItem&lt;/code&gt;组件将能够访问到&lt;code class=&quot;highlighter-rouge&quot;&gt;this.state.seconds&lt;/code&gt;属性。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后一步是改变&lt;code class=&quot;highlighter-rouge&quot;&gt;CartItem&lt;/code&gt;组件中的&lt;code class=&quot;highlighter-rouge&quot;&gt;render&lt;/code&gt;方法。我们将直接向视图中输出&lt;code class=&quot;highlighter-rouge&quot;&gt;this.state.seconds&lt;/code&gt;：&lt;/p&gt;

&lt;p&gt;```javascript
import React from ‘react’;
import { IntervalEnhance } from “./interval-enhance.jsx”;&lt;/p&gt;

&lt;p&gt;class CartItem extends React.Component {
    // component code here&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;render() {
    return &amp;lt;article className=&quot;row large-4&quot;&amp;gt;
            &amp;lt;!-- some other tags here --&amp;gt;                    
            &amp;lt;p className=&quot;large-12 column&quot;&amp;gt;
                &amp;lt;strong&amp;gt;Time elapsed for interval: &amp;lt;/strong&amp;gt;
                {this.props.seconds} ms
            &amp;lt;/p&amp;gt;    
        &amp;lt;/article&amp;gt;;
    } } export default IntervalEnhance(CartItem); ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在我们可以浏览器中检查结果了，我们将在页面中看到一行文字，显示用户在当前页面停留的时间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;所有这一切并没有改变&lt;code class=&quot;highlighter-rouge&quot;&gt;CartItem&lt;/code&gt;组件的任何主体代码（除了&lt;code class=&quot;highlighter-rouge&quot;&gt;render&lt;/code&gt;方法）！
这就是为什么高阶组件这么强大的原因！&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;装饰器*&lt;/h2&gt;

&lt;p&gt;此外，ECMAScript的未来标准中还将引入装饰器的概念，通过这种方法能够更优雅的解决Mixin的问题，
本文不对未标准化的特性做过多的介绍。不过，代码大致如下：&lt;/p&gt;

&lt;p&gt;```javascript
import React from ‘react’;
import { IntervalEnhance } from “./interval-enhance”;&lt;/p&gt;

&lt;p&gt;@IntervalEnhance
export default class CartItem extends React.Component {
    // component code here
}
```&lt;/p&gt;

&lt;h2 id=&quot;purerendermixin&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PureRenderMixin&lt;/code&gt;呢？&lt;/h2&gt;

&lt;p&gt;如果你使用了诸如&lt;code class=&quot;highlighter-rouge&quot;&gt;PureRenderMixin&lt;/code&gt;这样的mixins，那么酱油一些其他的方法来使用ES6将这种功能带到React组件中。
其中一种如下：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript
class Foo extends React.Component {
   constructor(props) {
     super(props);
     this.shouldComponentUpdate = React.addons.PureRenderMixin.shouldComponentUpdate.bind(this);
   }
   render () {
     return &amp;lt;div&amp;gt;Helllo&amp;lt;/div&amp;gt;
   }
}
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;小结&lt;/h2&gt;

&lt;p&gt;高阶组件非常的强大并且表达能力强。目前，它们使用非常广泛，并且可以作为古老的mixin语言的替代。&lt;/p&gt;

&lt;p&gt;对于高阶组件的使用最出名的要属&lt;a href=&quot;&quot;&gt;Relay&lt;/a&gt;框架。Relay是Facebook发布的一个完全的基于React的框架。
你所编写的没一个组件都可以被包裹进Relay容器，它能够自动检索数据依赖，以及一些其他的事。
这非常的便捷，并且在你刚接触的时候会觉得很神奇。&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://facebook.github.io/react/blog/2015/01/27/react-v0.13.0-beta-1.html#mixins&quot;&gt;About mixins in ES6 in official React blog&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750&quot;&gt;Mixins Are Dead. Long Live Composition by Dan Abramov&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://facebook.github.io/react/docs/jsx-spread.html&quot;&gt;JSX Spread Attributes&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://gist.github.com/ryanflorence/a93fd88d93cbf42d4d24&quot;&gt;Gist with PureRenderMixin in ES6&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Mon, 15 Feb 2016 00:00:00 +0800</pubDate>
        <link>twolun.github.com/posts/react-with-es6-part-4.html</link>
        <guid isPermaLink="true">twolun.github.com/posts/react-with-es6-part-4.html</guid>
        
        
        <category>knowledge</category>
        
      </item>
    
  </channel>
</rss>

<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>从零开始构建JavaScript模块化加载器</title>
    <meta name="description" content="">
    <!--<link rel="stylesheet" href="/assets/css/bootstrap.min.css">-->
    <!--<link rel="stylesheet" href="/assets/css/font-awesome.min.css">-->
    <link rel="icon" type="image/png" href="/favicon.ico">
    <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="http://fonts.useso.com/css?family=Roboto">
    <link rel="stylesheet" href="/assets/css/style.css">
    <link rel="stylesheet" href="/assets/css/syntax-highlight.css">
    
    <link rel="stylesheet" href="/assets/css/proj-layout.css">
    <script src="/assets/js/swiftype.js"></script>
    <!--<script src="/assets/js/jquery.js"></script>-->
    <!--<script src="/assets/js/modernizr.min.js"></script>-->
    <!--<script src="/assets/js/bootstrap.min.js"></script>-->
</head>

<body>
    <header>
    <nav class="navbar navbar-default" role="navigation">
        <div class="container">
            <div class="navbar-header">
                <p class="site-name"><a class="navbar-brand" href="/" title="twolun">朱子</a></p>
            </div>
            <div class="collapse navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="/">首页</a></li>
                    <li><a href="/project.html">项目总结</a></li>
                    <li><a href="/list.html">学习笔记</a></li>
                    <li><a href="/about.html">关于我</a></li>
                </ul>
            </div>
        </div>
    </nav>
    <!-- .site-navigation -->
</header>
    <div id="post-content" class="container">
        <br>
        <div class="well">
            <header class="page-header">
                <h1>从零开始构建JavaScript模块化加载器</h1>
                <p class="post-meta">Jun 22, 2015</p>
            </header>
            <article><p>对任何程序，都存在一个规模的问题，起初我们使用函数来组织不同的模块，但是随着应用规模的不断变大，简单的重构函数并不能顺利的解决问题。尤其对JavaScript程序而言，模块化有助于解决我们在前端开发中面临的越来越复杂的需求。</p>

<!--more-->

<h2 id="section">为什么需要模块化</h2>

<p>对开发者而言，有很多理由去将程序拆分为小的代码块。这种模块拆分的过程有助于开发者更清晰的阅读和编写代码，并且能够让编程的过程更多的集中在模块的功能实现上，和算法一样，分而治之的思想有助于提高编程生产率。</p>

<p>在本文中，我们将集中讨论JavaScript的模块化开发，并实现一个简单的module loader。对于模块化的基础知识，可以参考阅读<a href="http://eloquentjavascript.net/10_modules.html">这篇文章</a>。</p>

<h2 id="section-1">实现模块化</h2>

<h3 id="section-2">使用函数作为命名空间</h3>

<p>在JavaScript中，函数是唯一的可以用来创建新的作用域的途径。考虑到一个最简单的需求，我们通过数字来获得星期值，例如通过数字0得到星期日，通过数字1得到星期一。我们可以编写如下的程序：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>var names = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];

function dayName(number) {
    return names[number];
}

console.log(dayName(1));
</code></pre>
</div>

<p>上面的程序，我们创建了一个函数<code class="highlighter-rouge">dayName()</code>来获取星期值。但问题是，<code class="highlighter-rouge">names</code>变量被暴露在全局作用域中。更多的时候，我们希望能够构造私有变量，而暴露公共函数作为接口。</p>

<p>对JavaScript中的函数而言，我们可以通过创建立即调用的函数表达式来达到这个效果，我们可以通过如下的方式重构上面的代码，使得私有作用域成为可能：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>var dayName = function() {
    var names = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];

    return {
        name: function(number) {
            return names[number];
        },

        number: function(name) {
            return names.indexOf(name);
        }
    };
}();

console.log(dayName.name(3));
console.log(dayName.number("Sunday"));
</code></pre>
</div>

<p>上面的程序中，我们通过将变量包括在一个函数中，这个函数会立即执行，并返回一个包含两个属性的对象，返回的对象会被赋值给<code class="highlighter-rouge">dayName</code>变量。在后面，我们可以通过<code class="highlighter-rouge">dayName</code>变量来访问暴露的两个函数接口<code class="highlighter-rouge">name</code>和<code class="highlighter-rouge">number</code>。</p>

<p>对代码进一步改进，我们可以利用一个<code class="highlighter-rouge">exports</code>对象来达到暴露公共接口的目的，这种方法可以通过如下方法实现，代码如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>var weekDay = {};

(function(exports) {
    var names = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];

    exports.name = function(number) {
        return names[number];
    };

    exports.number = function(name) {
        return names.indexOf(name);
    };

})(weekDay); // outside of a function, this refers to the global scope object

console.log(weekDay.name(weekDay.number("Saturday")));
</code></pre>
</div>

<p>上面的这种模块构造方式在以浏览器为核心的前端编码中非常常见，通过暴露一个全局变量的方式来将代码包裹在私有的函数作用域中。但这种方法依然会存在问题，在复杂应用中，你依然无法避免同名变量。</p>

<h3 id="require">从全局作用域中分离，实现<code class="highlighter-rouge">require</code>方法</h3>

<p>更进一步的，为了实现模块化，我们可以通过构造一个系统，使得一个函数可以<code class="highlighter-rouge">require</code>另一个函数的方式来实现模块化编程。所以我们的目标是，实现一个<code class="highlighter-rouge">require</code>方法，通过传入模块名来取得该模块的调用。这种实现方式要比前面的方法更为优雅的体现模块化的理念。对<code class="highlighter-rouge">require</code>方法而言，我们需要完成两件事。</p>

<ol>
  <li>我们需要实现一个<code class="highlighter-rouge">readFile</code>方法，它能通过给定字符串返回文件的内容。</li>
  <li>我们需要能够将返回的字符串作为代码进行执行。</li>
</ol>

<p>我们假设已经存在了<code class="highlighter-rouge">readFile</code>这个方法，我们更加关注的是如何能够将字符串作为可执行的程序代码。通常我们有好几种方法来实现这个需求，最常见的方法是<code class="highlighter-rouge">eval</code>操作符，但我们常常在刚学习JavaScript的时候被告知，使用<code class="highlighter-rouge">eval</code>是一个非常不明智的决策，因为使用它会导致潜在的安全问题，因此我们放弃这个方法。</p>

<p>一个更好的方法是使用<code class="highlighter-rouge">Function</code>构造器，它需要两个参数：使用逗号分隔的参数列表字符串，和函数体字符串。例如：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>var plusOne = new Function("n", "return n+1");
console.log(plusOne(5)); // 6
</code></pre>
</div>

<p>下面我们可以来实现<code class="highlighter-rouge">require</code>方法了：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// module.js
function require(name) {
	
	// 调用一个模块，首先检查这个模块是否已被调用
    if(name in require.cache) {
        return require.cache[name];
    }

    var code = new Function("exports, module", readFile(name));
    var exports = {},
        module = {exports: exports};
    code(exports, module);

    require.cache[name] = module.exports;
    return module.exports;
}

// 缓存对象，为了应对重复调用的问题	
require.cache = Object.create(null);

// todo:
function readFile(fileName) { ... }
</code></pre>
</div>

<p>在页面中使用<code class="highlighter-rouge">require</code>函数：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"en"</span><span class="nt">&gt;</span>
<span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"UTF-8"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;title&gt;</span>demo<span class="nt">&lt;/title&gt;</span>
    <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"module.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;script&gt;</span>
        <span class="kd">var</span> <span class="nx">weekDay</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">"weekDay"</span><span class="p">);</span>
        <span class="kd">var</span> <span class="nx">today</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">"today"</span><span class="p">);</span>

        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">weekDay</span><span class="p">.</span><span class="nx">name</span><span class="p">(</span><span class="nx">today</span><span class="p">.</span><span class="nx">dayNumber</span><span class="p">()));</span>
    <span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre>
</div>

<p>通过这种方式实现的模块化系统通常被称为是<code class="highlighter-rouge">CommonJS模块</code>风格的，Node.js正式使用了这种风格的模块化系统。这里只是提供了一个最简单的实现方法，在真实应用中会有更加精致的实现方法。</p>

<h3 id="amd">慢载入模块和AMD</h3>

<p>对浏览器编程而言，通常不会使用<code class="highlighter-rouge">CommonJS</code>风格的模块化系统，因为对于Web而言，加载一个资源远没有在服务端来的快，这受到网络性能的影响，尤其一个模块如果过大的话，可能会阻塞当前的程序（JS是顺序执行的）。<a href="http://browserify.org/">Browserify</a>是解决这个问题的一个比较出名的模块化方案。</p>

<blockquote>
  <p>这个过程大概是这样的：首先检查模块中是否存在<code class="highlighter-rouge">require</code>其他模块的语句，如果有，就解析所有相关的模块，然后组装为一个大模块，通常我们称这个过程为线下构建，这样页面可以直接引用这个组装后的大资源。</p>
</blockquote>

<p>模块化的另一个解决方案是使用AMD，即异步模块定义，AMD允许通过异步的方式加载模块内容，这样就不会阻塞代码的执行。关于AMD的相关背景知识，可以参考<a href="http://requirejs.org/docs/whyamd.html">这篇文章</a>。</p>

<p>我们想要实现的功能大概是这个样子的：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// index.html 中的部分代码
define(["weekDay.js", "today.js"], function (weekDay, today) {
        console.log(weekDay.name(today.dayNumber()));
        document.write(weekDay.name(today.dayNumber()));
    });
</code></pre>
</div>

<p>问题的核心是实现<code class="highlighter-rouge">define</code>方法，它的第一个参数是定义该模块说需要的依赖列表，参数而是该模块的具体工作函数。一旦所依赖的模块都被加载后，<code class="highlighter-rouge">define</code>便会执行参数2所定义的工作函数。<code class="highlighter-rouge">weekDay</code>模块的内容大概是下面的内容：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// weekDay.js
define([], function() {
    var names = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];

    return {
        name: function(number) { return names[number]},
        number: function(name) { return names.indexOf(name)}
    }
});
</code></pre>
</div>

<p>下面我们来关注如何实现<code class="highlighter-rouge">define()</code>方法。为了实现这个方法，我们需要定义一个<code class="highlighter-rouge">backgroundReadFile()</code>方法来异步的获取文件内容。此外我们需要能够监视模块的加载状态，当模块加载完后能够告诉函数去执行具体的工作函数（回调）。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// 通过Ajax来异步加载模块
function backgroundReadFile(url, callback) {
    var req = new XMLHttpRequest();
    req.open("GET", url, true);
    req.addEventListener("load", function () {
        if (req.status &lt; 400)
            callback(req.responseText);
    });
    req.send(null);
}
</code></pre>
</div>

<p>通过实现一个<code class="highlighter-rouge">getModule</code>函数，通过给定的模块名进行模块的调度运行工作。此外，为了提高性能，我们需要通过缓存的方式避免同一个模块被重复的载入。实现代码如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// module.js 的部分内容
var defineCache = Object.create(null);
var currentMod = null;

function getModule(name) {
    if (name in defineCache) {
        return defineCache[name];
    }

    var module = {
        exports: null,
        loaded: false,
        onLoad: []
    };

    defineCache[name] = module;
    backgroundReadFile(name, function(code) {
        currentMod = module;
        new Function("", code)();
    });
    return module;
}
</code></pre>
</div>

<p>有了<code class="highlighter-rouge">getModule()</code>了函数之后，<code class="highlighter-rouge">define</code>方法可以借助该方法来为当前模块的依赖列表获取或创建模块对象。<code class="highlighter-rouge">define</code>方法的简单实现如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// module.js 的部分内容
function define(depNames, moduleFunction) {
    var myMod = currentMod;
    var deps = depNames.map(getModule);

    deps.forEach(function(mod) {
        if(!mod.loaded) {
            mod.onLoad.push(whenDepsLoaded);
        }
    });

	// 用于检查是否所有的依赖模块都被成功加载了
    function whenDepsLoaded() {
        if(!deps.every(function(m) { return m.loaded; })) {
            return;
        }

        var args = deps.map(function(m) { return m.exports; });

        var exports = moduleFunction.apply(null, args);
        if (myMod) {
            myMod.exports = exports;
            myMod.loaded = true;
            myMod.onLoad.forEach(function(f) { f(); });
        }
    }

    whenDepsLoaded();
}
</code></pre>
</div>

<p>关于AMD的最出名的实现是<a href="http://requirejs.org/">RequireJS</a>，它提供了AMD风格的更加全面的实现方式。</p>

<h2 id="section-3">小结</h2>

<p>模块通过将代码分离为不同的文件和命名空间，为大型程序提供了清晰的结构。通过构建良好的接口可以使得开发者更加建议的阅读、使用、扩展代码。尤其对JavaScript语言而言，由于天生的缺陷，使得模块化更加有助于程序的组织。在JavaScript的世界，有两种流行的模块化实现方式，一种称为CommonJS，通常是服务端的模块化实现方案，另一种称为AMD，通常针对浏览器环境。其他关于模块化的知识，你可以参考<a href="https://github.com/wwsun/fe-knowledge-points#modular">这篇文章</a>。</p>

<h2 id="references">References</h2>

<ol>
  <li>Eloquent JavaScript, chapter 10, Modules</li>
  <li><a href="http://www.alloyteam.com/2014/10/browserify-yun-xing-yuan-li-fen-xi/">Browserify运行原理分析</a></li>
  <li><a href="http://requirejs.org/docs/whyamd.html">Why AMD?</a></li>
  <li><a href="https://github.com/wwsun/fe-knowledge-points#modular">JavaScript模块化知识点小结</a></li>
</ol>
</article>
        </div>
    </div><!--#post-content-->

    <div id="ds-comment" class="container">
        <div class="ds-thread" data-thread-key="/posts/creating-javascript-modules-loader.html" data-title="从零开始构建JavaScript模块化加载器"></div>
        <script>
            var duoshuoQuery = {short_name:"wwsun"};  
            (function() {  
                var ds = document.createElement('script');  
                ds.type = 'text/javascript';
                ds.async = true;  
                ds.src = 'http://static.duoshuo.com/embed.js';  
                ds.charset = 'UTF-8';  
                (document.getElementsByTagName('head')[0]
                || document.getElementsByTagName('body')[0]).appendChild(ds);  
            })();
        </script>
    </div><!--#ds-comment-->

    <footer id="colophon" class="site-footer" role="contentinfo">
    <div class="site-info container">
        <div class="row">
            <nav id="menu-social" class="social-icons">
                <ul id="menu-social-items" class="social-menu">
                    <li><a href="https://github.com/twolun" title="Github" class="rss" target="_blank"><i class="social_icon fa fa-github"><span>Github</span></i></a></li>
                    <li><a href="/about.html#wechatQr" title="Wechat" class="facebook" target="_blank"><i class="fa fa-weixin"><span>Wechat</span></i></a></li>
                </ul>
            </nav>
            <nav role="navigation" class="col-md-6">
                <ul id="menu-flat-footer" class="nav footer-nav clearfix">
                    <li><a href="https://github.com/twolun">Github</a></li>
                    <li><a href="http://twolun.github.io/">Blog</a></li>
                </ul>
            </nav>
            <div class="copyright col-md-6">
                <a href="http://twolun.github.io/" title="Sparkling">朱了</a> All rights reserved. Theme by 
                <a href="https://pages.github.com/" target="_blank">Github Pages</a> and <a href="https://jekyllrb.com/" target="_blank">Jekyll</a>
            </div>
        </div>
    </div>
    <!-- .site-info -->
    <div class="scroll-to-top"><i class="fa fa-angle-up"></i></div>
    <!-- .scroll-to-top -->
</footer><!-- #colophon -->



</body>

</html>
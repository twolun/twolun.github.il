<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>理解JavaScript的闭包</title>
    <meta name="description" content="">
    <!--<link rel="stylesheet" href="/assets/css/bootstrap.min.css">-->
    <!--<link rel="stylesheet" href="/assets/css/font-awesome.min.css">-->
    <link rel="icon" type="image/png" href="/favicon.ico">
    <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="http://fonts.useso.com/css?family=Roboto">
    <link rel="stylesheet" href="/assets/css/style.css">
    <link rel="stylesheet" href="/assets/css/syntax-highlight.css">
    
    <link rel="stylesheet" href="/assets/css/proj-layout.css">
    <script src="/assets/js/swiftype.js"></script>
    <!--<script src="/assets/js/jquery.js"></script>-->
    <!--<script src="/assets/js/modernizr.min.js"></script>-->
    <!--<script src="/assets/js/bootstrap.min.js"></script>-->
</head>

<body>
    <header>
    <nav class="navbar navbar-default" role="navigation">
        <div class="container">
            <div class="navbar-header">
                <p class="site-name"><a class="navbar-brand" href="/" title="twolun">朱子</a></p>
            </div>
            <div class="collapse navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="/">首页</a></li>
                    <li><a href="/project.html">项目总结</a></li>
                    <li><a href="/list.html">学习笔记</a></li>
                    <li><a href="/about.html">关于我</a></li>
                </ul>
            </div>
        </div>
    </nav>
    <!-- .site-navigation -->
</header>
    <div id="post-content" class="container">
        <br>
        <div class="well">
            <header class="page-header">
                <h1>理解JavaScript的闭包</h1>
                <p class="post-meta">Mar 1, 2015</p>
            </header>
            <article><p>在JavaScript中，闭包是个常令新手困惑的术语，并且很容易和匿名函数相混淆。一句话来讲，
闭包是指有权访问另一个函数（嵌套函数）作用域中的变量的函数。本文将着重解释JavaScript中的闭包概念，
及其用法。</p>

<!--more-->

<blockquote>
  <p>A closure is a function plus the connection to the variables of its surrounding scopes.</p>
</blockquote>

<p>在讨论闭包之前，我们先回顾一下JavaScript中的词法作用域的概念。</p>

<h2 id="section">词法作用域</h2>

<p>处于种种原因，有时候我们<strong>需要得到函数内部的局部变量</strong>。通常情况下，这是无法做到的（函数内部变量属于局部变量），
只有通过变通方法才能实现。我们需要在函数内部再定义一个函数。比如有下面这个<a href="http://jsfiddle.net/xAFs9/3/">例子（在JSFIDDLE查看）</a>：</p>

<p>```javascript
function init() {</p>

<p>var name = “Mozilla”; // name是一个局部变量</p>

<p>// 内部函数，它是一个闭包
  function displayName() {
     console.log(name); // displayName()使用了外部函数中定义的变量  <br />
  }
displayName();  <br />
}</p>

<p>init();
```</p>

<p>上面的代码中，函数<code class="highlighter-rouge">displayName</code>是函数<code class="highlighter-rouge">init</code>的内函数，我们发现，可以在<code class="highlighter-rouge">displayName</code>中访问<code class="highlighter-rouge">init</code>的局部变量，但反过来却不可以。
也就是<code class="highlighter-rouge">displayName</code>内部的局部变量对<code class="highlighter-rouge">init</code>是不可见的。这就是Javascript语言特有的”链式作用域”结构（chain scope），
<strong>子对象会一级一级地向上寻找所有父对象的变量</strong>。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p>

<p>简单的说，内函数<code class="highlighter-rouge">displayName()</code>之所以能访问外函数中的<code class="highlighter-rouge">name</code>变量是因为JavaScript中的词法作用域的作用：
在avaScript中，变量的作用域是由它在源代码中所处位置决定的（词法），并且嵌套的函数可以访问到其外层作用域中声明的变量。</p>

<h2 id="section-1">闭包</h2>

<p>既然<code class="highlighter-rouge">displayName</code>可以访问<code class="highlighter-rouge">init</code>的局部变量，那么只要把<code class="highlighter-rouge">displayName</code>返回，
我们不就可以在<code class="highlighter-rouge">init</code>的外部读取到它的内部变量了吗！</p>

<p>现在考虑下面这个<a href="http://jsfiddle.net/wwsun/tyyqjn4y/">例子</a>：</p>

<p>```javascript
function makeFunc() {
  var name = “Mozilla”;</p>

<p>// 内函数可以访问外部函数的局部变量
  function displayName() {
    console.log(name);
  }
  return displayName; // 返回内部函数
}</p>

<p>var myFunc = makeFunc(); // myFunc成为了闭包
myFunc();  // Mozilla
```</p>

<p>代码的运行结果并没有变，所不同的是，内函数<code class="highlighter-rouge">displayName()</code>在<strong>执行之前被外函数返回了</strong>。</p>

<p>这段代码看起来别扭却能正常运行。通常，函数中的局部变量仅在函数的执行期间可用。
一旦 <code class="highlighter-rouge">makeFunc()</code> 执行过后，我们会很合理的认为 <code class="highlighter-rouge">name</code> 变量将不再可用。虽然代码运行的没问题，但实际并非如此。</p>

<p>对这一问题的解释就是，<code class="highlighter-rouge">myFunc</code>变成成一个<strong>闭包</strong>了。闭包是一种特殊的对象，它由两部分构成：</p>

<ul>
  <li>函数：<code class="highlighter-rouge">displayName()</code></li>
  <li>创建该函数的环境：环境由闭包创建时在作用域中的任何局部变量组成，即局部变量<code class="highlighter-rouge">name</code></li>
</ul>

<p>你可以简单的理解为：闭包就是能够读取其他函数内部变量的函数。而闭包通常是“定义在函数内部的函数”。
我们可以认为，闭包充当了函数内部和函数外部连接起来的桥梁。</p>

<p>创建闭包的一个常见方式就是在一个函数内部创建另一个函数。</p>

<h3 id="section-2">闭包用途</h3>

<ol>
  <li>读取函数内部的变量</li>
  <li><strong>让这些变量的值始终保存在内存中</strong></li>
</ol>

<p>注意，因为闭包会使得函数中变量都保存在内存中，因此不能滥用闭包，否则会造成内存溢出。</p>

<h3 id="section-3">作用域链</h3>

<p>之所以能访问这个变量，是因为内部函数的作用域链中包含了外函数<code class="highlighter-rouge">makeFunc()</code>的作用域。
要搞清楚其细节，就有必要了解作用域链（Scope Chain）的相关知识：</p>

<p>当某个函数第一次被调用时，会创建一个执行环境及相应的作用域链，
并把作用域链赋值给一个特殊的内部属性（即[scope]）。然后，
使用<code class="highlighter-rouge">this</code>、<code class="highlighter-rouge">arguments</code>和其他命名参数的值来初始化函数的活动对象。
但在作用域链中，外部函数的活动对象始终处于第二位，
外部函数的外部函数的活动对象处于第三位…直至作为作用域链终点的全局执行环境。</p>

<p>下面是一个<a href="http://jsfiddle.net/wwsun/kzmLLrg3/">更有趣的例子</a>，一个<code class="highlighter-rouge">makeAddr</code>函数：</p>

<p>```javascript
function makeAddr(x) {
  return function(y) {
    return x+y;  // 在内函数中访问外函数中的变量x
  };
}</p>

<p>// add5和add10都是闭包
var add5 = makeAddr(5);
var add10 = makeAddr(10);</p>

<p>console.log(add5(2)); // 7
console.log(add10(2)); // 12
```</p>

<p>在这个例子中，我们定义了函数<code class="highlighter-rouge">makeAddr(x)</code>, 其接收唯一的参数<code class="highlighter-rouge">x</code>，并且返回了一个新的函数。
被返回的函数也接收唯一的参数<code class="highlighter-rouge">y</code>，并返回<code class="highlighter-rouge">x</code>和<code class="highlighter-rouge">y</code>的和。</p>

<p>本质上，<code class="highlighter-rouge">makeAddr</code>可以认为是一个函数工厂——它创建了一个函数族，可以通过指定参数用来增加一个指定值。
在上面的例子中，我们使用这个函数工厂创建了两个新的函数，分别为add5和add10，一个用来增加5，另一个用来增加10。</p>

<p><code class="highlighter-rouge">add5</code>和<code class="highlighter-rouge">add10</code>都是闭包。它们共享相同的函数体定义，但是存放了不同的环境。
在<code class="highlighter-rouge">add5</code>的环境中，<code class="highlighter-rouge">x</code>的值为5；而在<code class="highlighter-rouge">add10</code>的环境中，<code class="highlighter-rouge">x</code>的值为10。</p>

<h2 id="section-4">闭包的三个事实</h2>

<p>付出努力掌握闭包将会给你带来超值的回报。理解闭包的三个事实：</p>

<ol>
  <li>
    <p>JavaScript允许你引用在当前函数意外定义的变量（依赖于词法作用域的作用）</p>

    <p>```javascript
 function makeSandwich() {
     var magicIngredit = “peanut butter”;
     function make(filling) {
         return magicIngredient + “ and “ + filling;	
     }	
     return make(“jelly”);
 }</p>

    <p>makeSandwich(); // “peanut butter and jelly”
 ```</p>
  </li>
  <li>
    <p>即使外部函数已经返回，当前函数仍然可以引用外部函数所定义的变量</p>
  </li>
</ol>

<p>```javascript
function sandwichMaker() {
  var magicIngredient = “peanut butter”;
  function make(filling) {
    console.log(magicIngredient + “ and “ + filling);
  }
  return make;
}</p>

<p>var f = sandwichMaker(); // f是一个闭包
f(“jelly”); 		// “peanut butter and jelly”
f(“bananas”);		// “peanut butter and bananas”
f(“marshmallows”);	// “peanut butter and marshmallorws”
```</p>

<p><code class="highlighter-rouge">f</code>的值实际上是内部返回的<code class="highlighter-rouge">make</code>函数，调用<code class="highlighter-rouge">f</code>也就是调用<code class="highlighter-rouge">make</code>。但即使<code class="highlighter-rouge">sandwichMaker</code>函数已经返回，
  <code class="highlighter-rouge">make</code>函数仍然能记住<code class="highlighter-rouge">magicIngredient</code>。</p>

<p>JavaScript中<strong>函数是一等公民</strong>，函数包含了比调用它们执行时所需要的代码还要多的信息。并且，
  JavaScript函数值还在内部存储它们可能会引用的定义在其封闭作用域的变量。
  <strong>那些在其所涵盖的作用域内跟踪变量的函数被称为闭包</strong>。</p>

<p>所以，<code class="highlighter-rouge">make</code>就是一个闭包，其代码引用了两个外部变量：<code class="highlighter-rouge">magicIngredient</code>和<code class="highlighter-rouge">filling</code>。
  每当<code class="highlighter-rouge">make</code>函数被调用时，其代码都能引用到这两个变量，因为该闭包存储了这两个变量。</p>

<ol>
  <li><strong>闭包可以更新外部变量的值</strong></li>
</ol>

<p>实际上，<strong>闭包存储的是外部变量的引用，而不是它们的值的副本</strong>。因此，对于任何具有访问这些外部变量的闭包，
  都可以进行更新。看一个例子就明白了：</p>

<p>```javascript
function box() {
  var val = undefined;
  return {
    set: function (newVal) { val = newVal; },
    get: function () { return val; },
    print: function () { console.log(val); },
    type: function () { return typeof val; }
  };
}</p>

<p>var b = box();
b.type();		// “undefined”
b.set(87.6);
b.get();		// 87.6
b.type();		// “number”
b.print();  // 87.6
```</p>

<h2 id="section-5">闭包实战</h2>

<p>上面我们已经讲完了闭包的理论部分，下面我们试着从实战角度看看闭包的具体应用。
<strong>闭包允许将函数与其所操作的某些数据（环境）关连起来</strong>。这显然类似于面向对象编程。
在面对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。</p>

<p>因而，一般说来，可以使用只有一个方法的对象的地方，都可以使用闭包。</p>

<p>在 Web 中，您可能想这样做的情形非常普遍。大部分我们所写的 Web JavaScript 代码都是事件驱动的 — 
定义某种行为，然后将其添加到用户触发的事件之上（比如点击或者按键）。我们的代码通常添加为回调：
响应事件而执行的函数。</p>

<p><a href="http://jsfiddle.net/vnkuZ/">这个例子</a>是这样的：假设我们想通过增加一些按钮来调整页面字体的大小。
一种方法是通过指定body元素在像素单位下的font-size，然后设置页面中其他元素使用<code class="highlighter-rouge">em</code>作为单位。</p>

<p>CSS代码如下：</p>

<p>```css
	body {
	  font-family: Helvetica, Arial, sans-serif;
	  font-size: 12px;
	}</p>

<div class="highlighter-rouge"><pre class="highlight"><code>h1 {
  font-size: 1.5em;
}
h2 {
  font-size: 1.2em;
} ```
</code></pre>
</div>

<p>我们通过点击按钮来改变body元素的字体大小，因为页面其他元素使用了相对单位<code class="highlighter-rouge">em</code>，
因此字体大小会相应的被调整。JavaScript代码如下：</p>

<p>```javascript
function makeSizer(size) {
  return function() {
	document.body.style.fontSize = size + ‘px’;
  };
}</p>

<p>var size12 = makeSizer(12);
var size14 = makeSizer(14);
var size16 = makeSizer(16);
```</p>

<p>函数<code class="highlighter-rouge">size12</code>, <code class="highlighter-rouge">size14</code>, <code class="highlighter-rouge">size16</code>分别用来调整body文本的大小为12，14， 16像素。
然后，我们可以将其与按钮元素绑定，如下：</p>

<p><code class="highlighter-rouge">javascript
document.getElementById('size-12').onclick = size12;
document.getElementById('size-14').onclick = size14;
document.getElementById('size-16').onclick = size16;
</code></p>

<p>html代码如下：</p>

<p>```html</p>
<p>Some paragraph text</p>
<h1>some heading 1 text</h1>
<h2>some heading 2 text</h2>

<p><a href="#" id="size-12">12</a>
<a href="#" id="size-14">14</a>
<a href="#" id="size-16">16</a>
```</p>

<h2 id="section-6">使用闭包来仿造私有方法</h2>

<p>在Java中你可以声明私有方法，私有方法表示只能在当前类中使调用该方法。
但是JavaScript并没有提供一个直接的方法去声明私有方法，但是可以使用闭包来仿造私有方法。
私有方法的作用不仅仅在于可以有效的限制代码的访问，
也为管理你的全局命名空间提供了一种强有力的方式，使得无关的方法不被公开的暴露出来。</p>

<p>下面来看如何<strong>定义可以访问私有函数和变量的公共函数</strong>，我们使用闭包来达到这一目的，
这也被称为<a href="https://www.google.com.hk/search?q=javascript+module+pattern&amp;gws_rd=cr">模块模式</a>：</p>

<p>```javascript
// 所定义的匿名函数表达式会立即执行，并将返回对象（含有三个方法）赋值给counter
var counter = (function() {
  var privateCounter = 0;</p>

<p>function changeBy(val) {
    privateCounter += val;
  }</p>

<p>return {
    increment: function() {
      changeBy(1);
    },
    decrement: function() {
      changeBy(-1);
    },
    value: function() {
      return privateCounter;
    }
  };
})();</p>

<p>console.log(counter.value()); // 0
counter.increment();
counter.increment();
console.log(counter.value()); // 2
counter.decrement();
console.log(counter.value()); // 1
```</p>

<p>这里有好多细节。<strong>在以往的示例中，每个闭包都有它自己的环境；而这次我们只创建了一个环境，为三个函数所共享</strong>，
分别是：<code class="highlighter-rouge">counter.increment</code>, <code class="highlighter-rouge">counter.decrement</code>, <code class="highlighter-rouge">counter.value</code>。</p>

<p>被共享的环境是在一个匿名函数的函数体内被创建的，这将会在其被定义后立即执行（立即执行函数 IIFE）。
这个共享环境包含两个私有项：变量<code class="highlighter-rouge">privateCounter</code>和函数<code class="highlighter-rouge">changeBy</code>，
外界无法直接访问匿名函数内部的这两个私有项。取而代之的是，只能通过访问三个公开的接口函数，也就是被匿名函数返回的三个函数。</p>

<p><strong>这三个公共函数是共享同一个环境（共享相同的<code class="highlighter-rouge">privateCounter</code>和<code class="highlighter-rouge">changeBy()</code>）的闭包</strong>，
而它们之所以都可以访问变量<code class="highlighter-rouge">privateCounter</code>和函数<code class="highlighter-rouge">changeBy</code>，是因为JavaScript词法作用域的作用。</p>

<p>您应该注意到了，我们定义了一个匿名函数用于创建计数器，然后直接调用该函数，并将返回值赋给 <code class="highlighter-rouge">counter</code> 变量。
也可以将这个函数保存到另一个变量中，以便创建多个计数器。</p>

<p>```javascript
// 此时我们没有使用立即执行函数表达式，而是直接定义了一个匿名函数
var counter = function() {
  var privateCounter = 0;</p>

<p>function changeBy(val) {
    privateCounter += val;
  }</p>

<p>return {
    increment: function() {
      changeBy(1);
    },
    decrement: function() {
      changeBy(-1);
    },
    value: function() {
      return privateCounter;
    }
  };
};</p>

<p>// 我们可以借助counter创建两个不同的计数器
var counter1 = counter();
var counter2 = counter();</p>

<p>// 每个计数器都有自己独立的环境
counter1.decrement();
counter1.decrement();
counter2.increment();</p>

<p>console.log(counter1.value());  // -2
console.log(counter2.value());  // 1
```</p>

<p>可以发现，这两个计数器是彼此独立的，它们的环境在函数<code class="highlighter-rouge">counter()</code>在调用期间是彼此不同的。
闭包变量<code class="highlighter-rouge">privateCounter</code>在每一次包含不同的实例。</p>

<p>利用这种方式使用闭包可以向OOP编程一样提供非常多的好处，尤其是<strong>数据隐藏和封装</strong>。</p>

<h3 id="iife">补充：立即执行函数 IIFE</h3>

<p>通过IIFE这种方式我们可以构造块作用域，通常的模式为：</p>

<p>```javascript
// 这是个立即执行的函数表达式，相当于Java中的一个普通的块作用域（里面的变量为局部变量）
(function () {
  var tmp = …; // 这里的tmp就是个局部变量</p>

<p>}());
```</p>

<p>IIFE是一种函数表达式，它在被定义后立即被调用。而在函数内部定义的变量自然是局部变量。</p>

<h2 id="section-7">在循环中创建闭包：一个常常会犯的错误</h2>

<p>在ES6引入<code class="highlighter-rouge">let</code>关键字之前，闭包的一个很常见的问题发生在循环中创建闭包。
考虑下面<a href="http://jsfiddle.net/v7gjv/">这个例子</a>：</p>

<p>HTML代码如下：</p>

<p>```html</p>
<p id="help">Helpful notes will appear here</p>
<p>E-mail: <input type="text" id="email" name="email" /></p>
<p>Name: <input type="text" id="name" name="name" /></p>
<p>Age: <input type="text" id="age" name="age" /></p>
<p>```</p>

<p>JavaScript代码如下：</p>

<p>```javascript
function showHelp(help) {
  document.getElementById(‘help’).innerHTML = help;
}</p>

<p>function setupHelp() {
  var helpText = [
    {‘id’: ‘email’, ‘help’: ‘Your e-mail address’},
    {‘id’: ‘name’, ‘help’: ‘Your full name’},
    {‘id’: ‘age’, ‘help’: ‘Your age (you must be over 16)’}
  ];</p>

<p>for (var i = 0; i &lt; helpText.length; i++) {
    var item = helpText[i];
    document.getElementById(item.id).onfocus = function() {
      showHelp(item.help);
    }
  }
}</p>

<p>setupHelp();
```</p>

<p>在<code class="highlighter-rouge">helpText</code>数组中我们定义了三个提示信息，每个都使用ID与html文档中的输入域相关联。
通过循环来迭代这些提示信息，将其分别与三个输入框的<code class="highlighter-rouge">onfocus</code>事件绑定，以在用户聚焦在不同的输入框时提示不同的信息。</p>

<p>如果你试着运行这些代码，会发现其并不会正常工作，无论你的焦点在哪个输入框中，提示都是关于年龄的那条信息。</p>

<p>该问题的原因在于赋给 <code class="highlighter-rouge">onfocus</code> 是闭包（showHelp）中的匿名函数而不是闭包对象；
在闭包（showHelp）中一共创建了三个匿名函数，但是它们都共享同一个环境（item）。
<strong>在 onfocus 的回调被执行时，循环早已经完成</strong>，且此时 <code class="highlighter-rouge">item</code> 变量（由所有三个闭包所共享）已经指向了 <code class="highlighter-rouge">helpText</code> 列表中的最后一项。</p>

<blockquote>
  <p>闭包只能取得包含函数中任何变量的最后一个值！闭包保存的是整个变量对象，而不是某个特殊的变量。</p>
</blockquote>

<p>解决这个问题的一种方案是使<code class="highlighter-rouge">onfocus</code>指向一个新的闭包对象。</p>

<p>```javascript
function showHelp(help) {
  document.getElementById(‘help’).innerHTML = help;
}</p>

<p>function makeHelpCallback(help) {
  return function() {
    showHelp(help);
  }
}</p>

<p>function setupHelp() {
  var helpText = [
    {‘id’: ‘email’, ‘help’: ‘Your e-mail address’},
    {‘id’: ‘name’, ‘help’: ‘Your full name’},
    {‘id’: ‘age’, ‘help’: ‘Your age (you must be over 16)’}
  ];</p>

<p>for (var i = 0; i &lt; helpText.length; i++) {
    var item = helpText[i];
    document.getElementById(item.id).onfocus = makeHelpCallback(item.help);
  }
}</p>

<p>setupHelp();
```</p>

<p>这段代码可以如我们所期望的那样工作。所有的回调不再共享同一个环境， 
<code class="highlighter-rouge">makeHelpCallback</code> 函数为每一个回调创建一个新的环境
。在这些环境中，<code class="highlighter-rouge">help</code> 指向 <code class="highlighter-rouge">helpText</code> 数组中对应的字符串。
<a href="http://jsfiddle.net/wwsun/grp341z3/">完整代码</a>。</p>

<h2 id="section-8">性能问题</h2>

<p>由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存，
过多使用闭包会使内存被占用过多，因此需要慎重使用闭包。</p>

<p>例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。
原因是这将导致每次构造器被调用，方法都会被重新赋值一次（也就是说，为每一个对象的创建）。</p>

<p>可以考虑一下下面的这个例子：</p>

<p>```javascript
function MyObject(name, message) {
  this.name = name.toString();
  this.message = message.toString();</p>

<p>this.getName = function() {
    return this.name;
  };</p>

<p>this.getMessage = function() {
    return this.message;
  };
}
```</p>

<p>这里的代码中并没有得到任何有关闭包的好处，因此可以重构为：</p>

<p>```javascript
function MyObject(name, message) {
  this.name = name.toString();
  this.message = message.toString();
}</p>

<p>MyObject.prototype = {</p>

<p>getName: function() {
    return this.name;
  },</p>

<p>getMessage: function() {
    return this.message;
  }
};
```</p>

<p>但是，重新定义原型显然也不是什么好方法，并且也是不被推荐的。
因此，更好的做法是将方法追加到已有原型上：</p>

<p>```javascript
function MyObject(name, message) {
  this.name = name.toString();
  this.message = message.toString();
}</p>

<p>MyObject.prototype.getName = function() {
  return this.name;
};</p>

<p>MyObject.prototype.getMessage = function() {
  return this.message;
};
```</p>

<p>在前面的例子中，被继承的原型可以被所有对象所贡献，并且方法定义也无需在每个对象创建时重新书写。
你可以参考JavaScirpt的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Details_of_the_Object_Model">对象模型</a>了解更多的内容。</p>

<h2 id="references">References</h2>

<ol>
  <li>http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html</li>
  <li>https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures</li>
  <li>JavaScript高级程序设计，第3版，第7章</li>
  <li>https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Closures</li>
  <li>https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Details_of_the_Object_Model</li>
  <li>Effective JavaScript, ch2, Item 11</li>
</ol>
</article>
        </div>
    </div><!--#post-content-->

    <div id="ds-comment" class="container">
        <div class="ds-thread" data-thread-key="/posts/javascript-closure.html" data-title="理解JavaScript的闭包"></div>
        <script>
            var duoshuoQuery = {short_name:"wwsun"};  
            (function() {  
                var ds = document.createElement('script');  
                ds.type = 'text/javascript';
                ds.async = true;  
                ds.src = 'http://static.duoshuo.com/embed.js';  
                ds.charset = 'UTF-8';  
                (document.getElementsByTagName('head')[0]
                || document.getElementsByTagName('body')[0]).appendChild(ds);  
            })();
        </script>
    </div><!--#ds-comment-->

    <footer id="colophon" class="site-footer" role="contentinfo">
    <div class="site-info container">
        <div class="row">
            <nav id="menu-social" class="social-icons">
                <ul id="menu-social-items" class="social-menu">
                    <li><a href="https://github.com/twolun" title="Github" class="rss" target="_blank"><i class="social_icon fa fa-github"><span>Github</span></i></a></li>
                    <li><a href="/about.html#wechatQr" title="Wechat" class="facebook" target="_blank"><i class="fa fa-weixin"><span>Wechat</span></i></a></li>
                </ul>
            </nav>
            <nav role="navigation" class="col-md-6">
                <ul id="menu-flat-footer" class="nav footer-nav clearfix">
                    <li><a href="https://github.com/twolun">Github</a></li>
                    <li><a href="http://twolun.github.io/">Blog</a></li>
                </ul>
            </nav>
            <div class="copyright col-md-6">
                <a href="http://twolun.github.io/" title="Sparkling">朱了</a> All rights reserved. Theme by 
                <a href="https://pages.github.com/" target="_blank">Github Pages</a> and <a href="https://jekyllrb.com/" target="_blank">Jekyll</a>
            </div>
        </div>
    </div>
    <!-- .site-info -->
    <div class="scroll-to-top"><i class="fa fa-angle-up"></i></div>
    <!-- .scroll-to-top -->
</footer><!-- #colophon -->



</body>

</html>
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>常用的Node.js设计模式</title>
    <meta name="description" content="">
    <!--<link rel="stylesheet" href="/assets/css/bootstrap.min.css">-->
    <!--<link rel="stylesheet" href="/assets/css/font-awesome.min.css">-->
    <link rel="icon" type="image/png" href="/favicon.ico">
    <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="http://fonts.useso.com/css?family=Roboto">
    <link rel="stylesheet" href="/assets/css/style.css">
    <link rel="stylesheet" href="/assets/css/syntax-highlight.css">
    
    <link rel="stylesheet" href="/assets/css/proj-layout.css">
    <script src="/assets/js/swiftype.js"></script>
    <!--<script src="/assets/js/jquery.js"></script>-->
    <!--<script src="/assets/js/modernizr.min.js"></script>-->
    <!--<script src="/assets/js/bootstrap.min.js"></script>-->
</head>

<body>
    <header>
    <nav class="navbar navbar-default" role="navigation">
        <div class="container">
            <div class="navbar-header">
                <p class="site-name"><a class="navbar-brand" href="/" title="twolun">朱子</a></p>
            </div>
            <div class="collapse navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="/">首页</a></li>
                    <li><a href="/project.html">项目总结</a></li>
                    <li><a href="/list.html">学习笔记</a></li>
                    <li><a href="/about.html">关于我</a></li>
                </ul>
            </div>
        </div>
    </nav>
    <!-- .site-navigation -->
</header>
    <div id="post-content" class="container">
        <br>
        <div class="well">
            <header class="page-header">
                <h1>常用的Node.js设计模式</h1>
                <p class="post-meta">Jul 17, 2015</p>
            </header>
            <article><p>当我们谈到设计模式的时候，你很可能会想到单例模式、观察者模式、工厂模式。本文并不会仅仅局限于介绍这些在Node编程中常见的设计模式，而且还会涉及到依赖注入、中间件等功能的介绍。</p>

<!--more-->

<h2 id="section">什么是设计模式</h2>

<blockquote>
  <p>A design pattern is a general, reusable solution to a commonly occurring problem.</p>
</blockquote>

<h3 id="section-1">单例模式</h3>

<p>单例模式将“类”的实例的个数限制为一个。在Node.js中创建单例模式非常的简单，只需要用<code class="highlighter-rouge">require</code>即可。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//area.js
var PI = Math.PI;

function circle (radius) {  
  return radius * radius * PI;
}

module.exports.circle = circle;  
</code></pre>
</div>

<p>无论你在应用中require这个模块多少次，这个模块的实例只会有一份存在。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>var areaCalc = require('./area');
console.log(areaCalc.circle(5));  
</code></pre>
</div>

<p>正因为<code class="highlighter-rouge">require</code>的这种行为，单例模式很可能是NPM模块中最常见的Node.js设计模式。</p>

<h3 id="section-2">观察者模式</h3>

<p>一个对象维护着一个依赖/观察者列表，并在状态改变的时候自动的通知列表中的每个成员。要实现观察者模式，可以借助于<code class="highlighter-rouge">EventEmitter</code>。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// MyFancyObservable.js
var util = require('util');  
var EventEmitter = require('events').EventEmitter;

function MyFancyObservable() {  
  EventEmitter.call(this);
}

util.inherits(MyFancyObservable, EventEmitter);  
</code></pre>
</div>

<p>这样我们就创建了一个可被观察的对象。为了让它更有用，我们可以为它增加点功能：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>MyFancyObservable.prototype.hello = function (name) {  
  this.emit('hello', name);
};
</code></pre>
</div>

<p>太好了，现在我们的观测者可以发出事件（<code class="highlighter-rouge">emit event</code>）了，让我们来试下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>var MyFancyObservable = require('MyFancyObservable');  
var observable = new MyFancyObservable();

observable.on('hello', function (name) {  
  console.log(name);
});

observable.hello('john'); 
</code></pre>
</div>

<h3 id="section-3">工厂模式</h3>

<p>工厂模式使我们不需要使用构造器，而是通过提供一个泛型（通用）接口来创建对象。这种模式在创建过程变得复杂时会非常有用。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>function MyClass (options) {  
  this.options = options;
}

function create(options) {  
  // modify the options here if you want
  return new MyClass(options);
}

module.exports.create = create;  
</code></pre>
</div>

<p>工厂也使得测试变得更加简单，因为你可以通过这种模式来注入模块的依赖。</p>

<h3 id="section-4">依赖注入</h3>

<blockquote>
  <p>Dependency injection is a software design pattern in which one or more dependencies (or services) are injected, or passed by reference, into a dependent object.</p>
</blockquote>

<p>在下面的例子中，我们将创建一个获取数据库依赖的<code class="highlighter-rouge">UserModel</code>类。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>function userModel (options) {  
  var db;

  if (!options.db) {
    throw new Error('Options.db is required');
  }

  db = options.db;

  return {
    create: function (done) {
      db.query('INSERT ...', done);
    }
  }
}

module.exports = userModel;  
</code></pre>
</div>

<p>然后，我们可以使用如下方法创建实例：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>var db = require('./db');

var userModel = require('User')({  
  db: db
});
</code></pre>
</div>

<p>为什么这很有用？因为这使得测试变得简单，当你写单元测试的时候，你可以很容易的注入一个假<code class="highlighter-rouge">db</code>对象到你的模型中。</p>

<h3 id="middlewares-pipelines">Middlewares/ pipelines</h3>

<p>中间件的概念很简单但却非常强大：一个单元/函数的输出是下一个的输入。如果你曾用过<code class="highlighter-rouge">Express</code>或<code class="highlighter-rouge">Koa</code>那么你肯定接触过。</p>

<p>我们来看看在Koa中是怎么做的：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>app.use = function(fn){  
  this.middleware.push(fn);
  return this;
};
</code></pre>
</div>

<p>也就是说，当你使用一个中间件的时候，它会被push到<code class="highlighter-rouge">middleware</code>数组中，这非常的赞，但是当请求到达服务器的时候发生了什么呢？</p>

<div class="highlighter-rouge"><pre class="highlight"><code>var i = middleware.length;  
while (i--) {  
  next = middleware[i].call(this, next);
}
</code></pre>
</div>

<p>原来没什么神奇的地方，你的中间件只不过是依次被循环遍历的调用了而已。</p>

<h3 id="streams">Streams</h3>

<p>你可以将流想象成一个特殊的管道。它们更擅长处理大量的流动数据，即使是它们是字节而不是对象。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>process.stdin.on('readable', function () {  
    var buf = process.stdin.read(3);
    console.dir(buf);
    process.stdin.read(0);
});
</code></pre>
</div>

<p>调用</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ (echo abc; sleep 1; echo def; sleep 1; echo ghi) | node consume2.js 
&lt;Buffer 61 62 63&gt;  
&lt;Buffer 0a 64 65&gt;  
&lt;Buffer 66 0a 67&gt;  
&lt;Buffer 68 69 0a&gt;  
</code></pre>
</div>

<p>有一本好书你可以参考一下：<a href="https://github.com/substack/stream-handbook">NodeJS Stream Handbook</a></p>

<h3 id="references">References</h3>

<ol>
  <li>英文原文 https://blog.risingstack.com/fundamental-node-js-design-patterns/</li>
</ol>
</article>
        </div>
    </div><!--#post-content-->

    <div id="ds-comment" class="container">
        <div class="ds-thread" data-thread-key="/posts/node-design-patterns.html" data-title="常用的Node.js设计模式"></div>
        <script>
            var duoshuoQuery = {short_name:"wwsun"};  
            (function() {  
                var ds = document.createElement('script');  
                ds.type = 'text/javascript';
                ds.async = true;  
                ds.src = 'http://static.duoshuo.com/embed.js';  
                ds.charset = 'UTF-8';  
                (document.getElementsByTagName('head')[0]
                || document.getElementsByTagName('body')[0]).appendChild(ds);  
            })();
        </script>
    </div><!--#ds-comment-->

    <footer id="colophon" class="site-footer" role="contentinfo">
    <div class="site-info container">
        <div class="row">
            <nav id="menu-social" class="social-icons">
                <ul id="menu-social-items" class="social-menu">
                    <li><a href="https://github.com/twolun" title="Github" class="rss" target="_blank"><i class="social_icon fa fa-github"><span>Github</span></i></a></li>
                    <li><a href="/about.html#wechatQr" title="Wechat" class="facebook" target="_blank"><i class="fa fa-weixin"><span>Wechat</span></i></a></li>
                </ul>
            </nav>
            <nav role="navigation" class="col-md-6">
                <ul id="menu-flat-footer" class="nav footer-nav clearfix">
                    <li><a href="https://github.com/twolun">Github</a></li>
                    <li><a href="http://twolun.github.io/">Blog</a></li>
                </ul>
            </nav>
            <div class="copyright col-md-6">
                <a href="http://twolun.github.io/" title="Sparkling">朱了</a> All rights reserved. Theme by 
                <a href="https://pages.github.com/" target="_blank">Github Pages</a> and <a href="https://jekyllrb.com/" target="_blank">Jekyll</a>
            </div>
        </div>
    </div>
    <!-- .site-info -->
    <div class="scroll-to-top"><i class="fa fa-angle-up"></i></div>
    <!-- .scroll-to-top -->
</footer><!-- #colophon -->



</body>

</html>
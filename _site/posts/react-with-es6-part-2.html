<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>使用ES6编写React应用（2）：类组件的属性与状态</title>
    <meta name="description" content="">
    <!--<link rel="stylesheet" href="/assets/css/bootstrap.min.css">-->
    <!--<link rel="stylesheet" href="/assets/css/font-awesome.min.css">-->
    <link rel="icon" type="image/png" href="/favicon.ico">
    <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="http://fonts.useso.com/css?family=Roboto">
    <link rel="stylesheet" href="/assets/css/style.css">
    <link rel="stylesheet" href="/assets/css/syntax-highlight.css">
    
    <link rel="stylesheet" href="/assets/css/proj-layout.css">
    <script src="/assets/js/swiftype.js"></script>
    <!--<script src="/assets/js/jquery.js"></script>-->
    <!--<script src="/assets/js/modernizr.min.js"></script>-->
    <!--<script src="/assets/js/bootstrap.min.js"></script>-->
</head>

<body>
    <header>
    <nav class="navbar navbar-default" role="navigation">
        <div class="container">
            <div class="navbar-header">
                <p class="site-name"><a class="navbar-brand" href="/" title="twolun">朱子</a></p>
            </div>
            <div class="collapse navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="/">首页</a></li>
                    <li><a href="/project.html">项目总结</a></li>
                    <li><a href="/list.html">学习笔记</a></li>
                    <li><a href="/about.html">关于我</a></li>
                </ul>
            </div>
        </div>
    </nav>
    <!-- .site-navigation -->
</header>
    <div id="post-content" class="container">
        <br>
        <div class="well">
            <header class="page-header">
                <h1>使用ES6编写React应用（2）：类组件的属性与状态</h1>
                <p class="post-meta">Feb 12, 2016</p>
            </header>
            <article><p>构建React应用一个基础场景是在组件中进行状态的传递与管理，通常我们需要借助组件的状态和属性来进行数据传递。
因此作为本系列的第二篇，本文将介绍如何基于ES6在React的类组件中设置组件的属性与状态。</p>

<!--more-->

<h2 id="statement">Statement</h2>

<ul>
  <li><strong>作者：</strong> <a href="http://wwsun.github.com">景庄</a>，Web开发者，主要关注JavaScript、Node.js、React、Docker等。</li>
  <li><strong>源码：</strong> 本文的源代码地址：https://github.com/wwsun/react-es6-tutorial</li>
</ul>

<h2 id="section">介绍</h2>

<p>在本文中，我们将进一步的学习React应用构建的更进一步的知识，我们将会创建一个更复杂的React组件<code class="highlighter-rouge">CartItem</code>。
该组件将会展示一个简单的产品信息预览图，包括产品的图片、价格、数量，你可以通过点击按钮增加或减少产品的数量，
并且组件能够基于产品的数量和价格，自动计算总价。</p>

<p>本文所构建的应用的最终下过如下图所示：</p>

<p><img src="http://7xpv9g.com1.z0.glb.clouddn.com/imgreact-with-es6-part2-preview.JPG" alt="app preivew" /></p>

<h3 id="section-1">组件状态</h3>

<p>组件主要通过两种方式管理状态数据：最常见的是通过<code class="highlighter-rouge">this.props</code>接收输入数据，
组件还可以保持内部状态数据（通过<code class="highlighter-rouge">this.state</code>）。当一个组件的状态数据发生变化时，
视图层将会通过<code class="highlighter-rouge">render()</code>方法进行重新渲染。</p>

<p>关于如何区分组件的<code class="highlighter-rouge">props</code>和<code class="highlighter-rouge">state</code>，请参考这篇<a href="http://facebook.github.io/react/docs/interactivity-and-dynamic-uis.html">官方文档</a>。</p>

<h2 id="section-2">应用构建</h2>

<h3 id="section-3">创建视图</h3>

<p>视图主要引入了基础的样式，<code class="highlighter-rouge">home.html</code>文件的内容如下：</p>

<p>```html
&lt;!DOCTYPE html&gt;</p>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>React.js with ES6</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/foundation/5.5.2/css/foundation.min.css" />
</head>
<body>

<div id="react-app"></div>

<!--<script src="bundle.js"></script>-->
<script src="http://localhost:8080/bundle.js"></script>
</body>
</html>
<p>```</p>

<p>上面我们通过CDN引入了<a href="http://foundation.zurb.com/">Foundation CSS</a>的基础样式库，对于构建一个小型应用而言，这已经足够了。
此外<code class="highlighter-rouge">div.react-app</code>作为React应用的加载点。</p>

<h3 id="root">Root组件</h3>

<p>首先是<code class="highlighter-rouge">root.jsx</code>：</p>

<p>```javascript
// src/component/root.jsx
import React from ‘react’;
import CartItem from ‘./cart-item.jsx’;</p>

<p>const order = {
  title: ‘Fresh fruits package’,
  image: ‘http://7xpv9g.com1.z0.glb.clouddn.com/fruit-image.jpg’,
  initialQty: 3,
  price: 8
};</p>

<p>class Root extends React.Component {
  render() {
    return &lt;CartItem title={order.title}
                    image={order.image}
                    initalQty={order.initialQty}
                    price={order.price} /&gt;;
  }
}</p>

<p>export default Root;
```</p>

<p>我建议使用<code class="highlighter-rouge">root.jsx</code>文件作为React组件树的根组件，这样我们无需反复的修改应用的入口文件（即<code class="highlighter-rouge">main.jsx</code>），
在根组件中我们导入相关的子组件，并完成对组件树的拼装。</p>

<p>此外我们还在该组件中添加了应用的初始数据<code class="highlighter-rouge">order</code>，我们通过组件属性的方式将数据传递给子组件。</p>

<h3 id="cartitem">CartItem组件</h3>

<p>其次是<code class="highlighter-rouge">cart-item.jsx</code>：</p>

<p>```javascript
// src/components/cart-tem.jsx
import React from ‘react’;</p>

<p>class CartItem extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      qty: props.initialQty,
      image: props.image,
      price: props.price,
      total: 0
    };
  }</p>

<p>componentWillMount() {
    this.recalculateTotal();
  }</p>

<p>increaseQty() {
    this.setState({ qty: this.state.qty + 1 }, this.recalculateTotal);
  }</p>

<p>decreaseQty() {
    this.setState({ qty: this.state.qty - 1}, this.recalculateTotal);
  }</p>

<p>recalculateTotal() {
    this.setState({ total: this.state.qty * this.props.price });
  }</p>

<p>render() {
    // TBD
  }
}</p>

<p>export default CartItem;
```</p>

<ul>
  <li>首先，我们关注的是类的构造器<code class="highlighter-rouge">constructor(props)</code>，必须要在构造器的第一行首先调用<code class="highlighter-rouge">super(props)</code>，
其次是在构造器中使用实例属性<code class="highlighter-rouge">this.state</code>来设置初始组件的state，通过这种方式来替React代传统的<code class="highlighter-rouge">getInitialState()</code>生命周期方法。</li>
  <li>其实，其他的组件生命周期方法都使用<code class="highlighter-rouge">componentWillMount()</code>方法这种方式进行声明，在该方法中进行<strong>总价</strong>的重新计算。</li>
  <li>最后，<code class="highlighter-rouge">increaseQty()</code>和<code class="highlighter-rouge">decreaseQty()</code>方法分别用来响应用户在点击对应按钮时对数量的修改。
需要注意的是，我们还利用了<code class="highlighter-rouge">this.state()</code>方法的第二个参数（回调函数）用来重新计算<strong>总价</strong>。</li>
</ul>

<blockquote>
  <p>在ES6中，当我们创建一个类的时候，类的定义中有一个<code class="highlighter-rouge">constructor</code>方法，这个方法控制着所有静态方法，
实际上，我们正是依据这个方法创建了一个新的函数；然后我们又创建一个对象并将它赋给这个函数的<code class="highlighter-rouge">prototype</code>属性。
为了使新创建的类集成所有的静态属性，我们需要让这个新的函数对象集成超类的函数对象；同样，
为了使新创建的类集成所有的实例方法，我们需要让新函数的<code class="highlighter-rouge">prototype</code>对象集成超类的<code class="highlighter-rouge">prototype</code>对象。</p>
</blockquote>

<p>在ES6中，我们利用<code class="highlighter-rouge">extends</code>关键字来创建子类，子类可以继承父类的属性，有时我们会在子类中重新定义同名方法，
这样会覆盖掉我们继承的方法。但在某些情况下，如果你重新定义了一个方法，但有时你又想绕开这个方法去使用父类中的同名方法，
应该怎样做？</p>

<p><code class="highlighter-rouge">super</code>是一个全新的关键字，它可以帮我们绕开我们子类中定义的属性，直接从子类的原型开始查找属性，
从而绕过我们覆盖到父类上的同名方法。在子类构造函数中，我们可以通过<code class="highlighter-rouge">super()</code>调用父类构造函数。</p>

<h3 id="cartitemrender">CartItem组件的<code class="highlighter-rouge">render()</code>方法</h3>

<p>现在我们需要做的是完善组件的<code class="highlighter-rouge">render()</code>方法，这里使用的是JSX,用来渲染组件的视图。</p>

<p>```javascript
  render() {
    return <aricle classname="row large-4">
      <figure classname="text-center">
        &lt;p&gt;&lt;img src={this.state.image} alt="image"/&gt;&lt;/p&gt;
        &lt;figcaption&gt;&lt;h2&gt;{this.state.title}&lt;/h2&gt;&lt;/figcaption&gt;
      </figure></aricle></p>

<div class="highlighter-rouge"><pre class="highlight"><code>  &lt;p className="large-4 column"&gt;&lt;strong&gt;Quantity: {this.state.qty}&lt;/strong&gt;&lt;/p&gt;

  &lt;p className="large-4 column"&gt;
    &lt;button onClick={this.increaseQty.bind(this)} className="button success"&gt;+&lt;/button&gt;
    &lt;button onClick={this.decreaseQty.bind(this)} className="button alert"&gt;-&lt;/button&gt;
  &lt;/p&gt;

  &lt;p className="large-4 column"&gt;&lt;strong&gt;Price per item:&lt;/strong&gt; ${this.state.price}&lt;/p&gt;

  &lt;h3 className="large-12 column text-center"&gt;Total: ${this.state.total}&lt;/h3&gt;

&lt;/aricle&gt;   } ```
</code></pre>
</div>

<p>在上面的代码中，可能最值得我们关注的是<code class="highlighter-rouge">&lt;button onClick={this.increaseQty.bind(this)}&gt;+&lt;/button&gt;</code>，
为了调用组件中的<code class="highlighter-rouge">increaseQty()</code>方法，我们使用<code class="highlighter-rouge">bind()</code>进行绑定。之所以这么做，将在下一篇文章进行解释。</p>

<p>目前我们已经完成了一个简单的能够与用户进行交互的React组件。虽然这个例子非常的简单，
但是它能够非常直观的向你展示如何使用ES6编写React组件。我个人非常喜欢ES6这种书写方式。</p>

<h3 id="section-4">默认属性值和属性类型</h3>

<p>如果我们需要给<code class="highlighter-rouge">CartItem</code>组件添加一些值的验证和默认值，我们该怎么做？</p>

<p>幸运的是，React内置了这两项功能，被称为Default Props和Prop Types。
你可以通过<a href="https://facebook.github.io/react/docs/reusable-components.html">这篇文章</a>来了解。</p>

<p>在<code class="highlighter-rouge">CartItem</code>类下面添加如下代码：</p>

<p>```javascript
CartItem.propTypes = {
  title: React.PropTypes.string.isRequired,
  price: React.PropTypes.number.isRequired,
  initialQty: React.PropTypes.number
};</p>

<p>CartItem.defaultProps = {
  title: ‘Undefined Product’,
  price: 0,
  initialQty: 0
};
```</p>

<p>现在，如果你将<code class="highlighter-rouge">title</code>属性的值设为数字的话，你将会在控制台中发现对应的警告信息，这就得益于React的属性验证机制。</p>

<h2 id="section-5">小结</h2>

<p>本节我们简要介绍了使用ES6编写React组件，以及组件间如何进行数据的传递，包括组件的属性（props）和状态（state）。</p>

<h2 id="section-6">参考</h2>

<ol>
  <li><a href="http://egorsmirnov.me/2015/06/14/react-and-es6-part2.html">React and ES6, part 2</a></li>
  <li><a href="http://www.2ality.com/2015/02/es6-classes-final.html">ES6 Classes final</a></li>
  <li><a href="http://exploringjs.com/es6/ch_classes.html">Exploring ES6: Classes</a></li>
</ol>
</article>
        </div>
    </div><!--#post-content-->

    <div id="ds-comment" class="container">
        <div class="ds-thread" data-thread-key="/posts/react-with-es6-part-2.html" data-title="使用ES6编写React应用（2）：类组件的属性与状态"></div>
        <script>
            var duoshuoQuery = {short_name:"wwsun"};  
            (function() {  
                var ds = document.createElement('script');  
                ds.type = 'text/javascript';
                ds.async = true;  
                ds.src = 'http://static.duoshuo.com/embed.js';  
                ds.charset = 'UTF-8';  
                (document.getElementsByTagName('head')[0]
                || document.getElementsByTagName('body')[0]).appendChild(ds);  
            })();
        </script>
    </div><!--#ds-comment-->

    <footer id="colophon" class="site-footer" role="contentinfo">
    <div class="site-info container">
        <div class="row">
            <nav id="menu-social" class="social-icons">
                <ul id="menu-social-items" class="social-menu">
                    <li><a href="https://github.com/twolun" title="Github" class="rss" target="_blank"><i class="social_icon fa fa-github"><span>Github</span></i></a></li>
                    <li><a href="/about.html#wechatQr" title="Wechat" class="facebook" target="_blank"><i class="fa fa-weixin"><span>Wechat</span></i></a></li>
                </ul>
            </nav>
            <nav role="navigation" class="col-md-6">
                <ul id="menu-flat-footer" class="nav footer-nav clearfix">
                    <li><a href="https://github.com/twolun">Github</a></li>
                    <li><a href="http://twolun.github.io/">Blog</a></li>
                </ul>
            </nav>
            <div class="copyright col-md-6">
                <a href="http://twolun.github.io/" title="Sparkling">朱了</a> All rights reserved. Theme by 
                <a href="https://pages.github.com/" target="_blank">Github Pages</a> and <a href="https://jekyllrb.com/" target="_blank">Jekyll</a>
            </div>
        </div>
    </div>
    <!-- .site-info -->
    <div class="scroll-to-top"><i class="fa fa-angle-up"></i></div>
    <!-- .scroll-to-top -->
</footer><!-- #colophon -->



</body>

</html>
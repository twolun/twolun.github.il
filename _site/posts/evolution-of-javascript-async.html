<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>异步JavaScript的发展历程</title>
    <meta name="description" content="">
    <!--<link rel="stylesheet" href="/assets/css/bootstrap.min.css">-->
    <!--<link rel="stylesheet" href="/assets/css/font-awesome.min.css">-->
    <link rel="icon" type="image/png" href="/favicon.ico">
    <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="http://fonts.useso.com/css?family=Roboto">
    <link rel="stylesheet" href="/assets/css/style.css">
    <link rel="stylesheet" href="/assets/css/syntax-highlight.css">
    
    <link rel="stylesheet" href="/assets/css/proj-layout.css">
    <script src="/assets/js/swiftype.js"></script>
    <!--<script src="/assets/js/jquery.js"></script>-->
    <!--<script src="/assets/js/modernizr.min.js"></script>-->
    <!--<script src="/assets/js/bootstrap.min.js"></script>-->
</head>

<body>
    <header>
    <nav class="navbar navbar-default" role="navigation">
        <div class="container">
            <div class="navbar-header">
                <p class="site-name"><a class="navbar-brand" href="/" title="twolun">朱子</a></p>
            </div>
            <div class="collapse navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="/">首页</a></li>
                    <li><a href="/project.html">项目总结</a></li>
                    <li><a href="/list.html">学习笔记</a></li>
                    <li><a href="/about.html">关于我</a></li>
                </ul>
            </div>
        </div>
    </nav>
    <!-- .site-navigation -->
</header>
    <div id="post-content" class="container">
        <br>
        <div class="well">
            <header class="page-header">
                <h1>异步JavaScript的发展历程</h1>
                <p class="post-meta">Sep 10, 2015</p>
            </header>
            <article><p>对大部分的JavaScript开发者而言，<code class="highlighter-rouge">async</code>函数是个新鲜事物，它的发展经历了一个漫长的旅程。因此本文试图
梳理总结JavaScript异步函数的发展历程：在不久之前，我们还只能写回调函数来实现异步，然后Promise/A+
标准出来了，这之后又出现了生成器函数，而未来显然是<code class="highlighter-rouge">async</code>函数的。</p>

<p>现在让我们、一起来回顾这些年来JavaScript异步函数的发展历程吧。</p>

<!--more-->
<p>## Statement</p>

<blockquote>
  <p>未经允许，请勿转载。原文地址：https://blog.risingstack.com/asynchronous-javascript/</p>
</blockquote>

<h2 id="callbacks">回调函数 Callbacks</h2>

<p>似乎一切应该从<a href="https://blog.risingstack.com/node-js-best-practices/">回调函数</a>开始谈起。</p>

<h3 id="javascript">异步JavaScript</h3>

<p>正如我们所知道的那样，在JavaScript中，异步编程方式只能通过JavaScript语言中的一等公民函数才能完成：
这种方式意味着我们可以将一个函数作为另一个函数的参数，在这个函数的内部可以调用被传递进来的函数（即回调函数）。
这也正是回调函数诞生的原因：如果你将一个函数作为参数传递给另一个函数（此时它被称为高阶函数），那么在函数内部，
你可以调用这个函数来来完成相应的任务。回调函数没有返回值（不要试图用<code class="highlighter-rouge">return</code>），仅仅被用来在函数内部执行某些动作。
看一个例子：</p>

<p>```javascript
const fs = require(‘fs’)</p>

<p>console.log(‘start reading a file…’)</p>

<p>fs.readFile(‘file.md’, ‘utf-8’, function (err, content) {<br />
  if (err) {
    console.log(‘error happened during reading the file’)
    return console.log(err)
  }</p>

<p>console.log(content)
})</p>

<p>console.log(‘end of the file’)<br />
```</p>

<p>输出结果是：</p>

<p><code class="highlighter-rouge">bash
start reading a file...  
end of the file  
error happened during reading the file  
</code></p>

<p>上面的例子中我们演示了一个错误优先的回调函数（error-first callbacks），这也是Node.js本身的特点之一，
Node.js中所有的核心模块和NPM仓库中的大部分模块在编写时都会遵循这个特点。</p>

<p>简单总结一下在Node.js中使用回调函数进行编程点特点：</p>

<ul>
  <li><strong>错误优先</strong></li>
  <li><strong>没有返回值</strong>: 异步函数没有返回值，值将会被传递给回调函数。</li>
</ul>

<p>过度使用回调函数所会遇到的挑战：</p>

<ul>
  <li>如果不能合理的组织代码，非常容易造成回调地狱（callback hell），这会使得你的代码很难被别人所理解。</li>
  <li>很容易遗漏错误处理代码</li>
  <li>无法使用<code class="highlighter-rouge">return</code>语句返回值，并且也不能使用<code class="highlighter-rouge">throw</code>关键字</li>
</ul>

<p>也正是基于这些原因，在JavaScript世界中，一直都在寻找着能够让异步JavaScript开发变得更简单的可行的方案。</p>

<p>一个可行的解决方案之一是<a href="https://www.npmjs.com/package/async">async</a>模块。如果你和回调函数打过很久的交道，
你也许会深刻的感受到，在JavaScript中如果想要让某些事并行执行，或是串行执行，甚至是使用异步函数来映射（mapping）
数组中的元素使用异步函数有多复杂。所以，感谢<a href="https://twitter.com/caolan">Caolan McMahon</a>写了async模块来
解决这些问题。</p>

<p>使用<code class="highlighter-rouge">async</code>模块，你可以轻松像下面这样的方式编写代码：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>async.map([1, 2, 3], AsyncSquaringLibrary.square,  
	function(err, result){
		// result will be [1, 4, 9]
});	
</code></pre>
</div>

<p>async模块虽然一定程度上带来了便利，但仍然不够简单，代码也不容易阅读，因此Promise出现了。</p>

<h2 id="promise">Promise</h2>

<p>当前的JavaScript异步标准可以追溯到2012年，并且直到ES6才变得可用，然而，Promise这个术语却并不是JavaScript
社区所发明的。这个术语来来自于<a href="https://en.wikipedia.org/wiki/Daniel_P._Friedman">Daniel P.friedman</a>
在1976年的发表的一篇文章。</p>

<p><strong>一个Promise代表的是一个异步操作的最终结果。</strong></p>

<p>现在我们使用Promise来完成上面代码所完成的任务，Promise风格的代码如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Something.save()  
	.then(function() {
		console.log('success');
	})
	.catch(function() {
		//error handling
	})
</code></pre>
</div>

<p>你会发现，Promise中也利用了回调函数。在<code class="highlighter-rouge">then</code>和<code class="highlighter-rouge">catch</code>方法中都传入了一个回调函数，分别在Promise被
满足和被拒绝时执行。Promise函数的另一个优点是它能够被链接起来完成一系列任务。例如，你可以这样写代码：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>saveSomething()  
	.then(updateOtherthing)
	.then(deleteStuff)  
	.then(logResults);
</code></pre>
</div>

<p>当你没有现成的Promise时，你可能需要借助一些Promise库，一个流行的选择是使用<a href="https://github.com/petkaantonov/bluebird">bluebird</a>。
这些库可能会提供比原生方案更多的功能，并且不局限于Promise/A+标准所规定的特性。</p>

<p>但是你为什么不用糖方法（sugar methods）呢？建议你首先阅读<a href="http://blog.getify.com/promises-part-4/">Promise: The Extension Problem</a>
这篇文章。更多关于Promise的信息，可以参考<a href="https://promisesaplus.com/">Promise/A+标准</a>。</p>

<p>你可能会问： 如果大部分的库只暴露了回调的接口的话，那么我该如何使用Promise？
嗯，这个很简单，此时你唯一需要做的就是使用Promise来包裹含有回调的那个函数调用体。举例说明：</p>

<p>回调风格的代码可能是这样的：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>function saveToTheDb(value) {
	db.values.insert(value, function (err, user) {
		if (err) throw err;
		
		// todo: insert user to db
	});
}
</code></pre>
</div>

<p>现在我们来将其改成支持Promise风格调用的代码：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>function saveToTheDb(value) {  
	return new Promise(function(resolve, reject) {
		db.values.insert(value, function(err, user) { // remember error first ;)
			if (err) {
				return reject(err); // don't forget to return here
			}
			resolve(user);
		})
	}
}
</code></pre>
</div>

<p>已经有相当一部分的库或框架同时支持者两种方式了，即同时提供了回调风格和Promise风格的API接口。那么现在，
如果你也想对外提供一个库，最佳实践也是同时提供两种方式的接口。你可以轻松的使用如下方式来达到这个目的：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>function foo(cb) {  
	if (cb) {
		return cb();
	}
	
	return new Promise(function (resolve, reject) {
	
	});
}
</code></pre>
</div>

<p>或者更简单些，你可以从只提供Promise风格的接口开始后，并使用诸如<a href="https://www.npmjs.com/package/callbackify">callbackify</a>
这样的工具来达到向后兼容的目的。其实Callbackify所做的工作和上面的代码片段类似，但在实现上使用了一个更通用的方法，
我建议你可以去阅读Callbackify的源代码。</p>

<h2 id="generators-yield">生成器Generators/ yield</h2>

<p>JavaScript<a href="https://blog.risingstack.com/introduction-to-koa-generators/">生成器</a>是个相对较新的概念，
它是ES6（也被称为ES2015）的新特性。想象下面这样的一个场景：</p>

<blockquote>
  <p>当你在执行一个函数的时候，你可以在某个点暂停函数的执行，并且做一些其他工作，然后再返回这个函数继续执行，
甚至是携带一些新的值，然后继续执行。</p>
</blockquote>

<p>上面描述的场景正是JavaScript生成器函数所致力于解决的问题。当我们调用一个生成器函数的时候，它并不会立即执行，
而是需要我们手动的去执行迭代操作（<code class="highlighter-rouge">next</code>方法）。也就是说，你调用生成器函数，它会返回给你一个迭代器。迭代器
会遍历每个中断点。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>function* foo () {  
	var index = 0;
	while (index &lt; 2) {
		yield index++; //暂停函数执行，并执行yield后的操作
	}
}
var bar =  foo(); // 返回的其实是一个迭代器

console.log(bar.next());    // { value: 0, done: false }  
console.log(bar.next());    // { value: 1, done: false }  
console.log(bar.next());    // { value: undefined, done: true }  
</code></pre>
</div>

<p>更进一步的，如果你想更轻松的使用生成器函数来编写异步JavaScript代码，我们可以使用<a href="https://www.npmjs.com/package/co">co</a>
这个库，co是著名的tj大神写的。</p>

<blockquote>
  <p>Co是一个为Node.js和浏览器打造的基于生成器的流程控制工具，借助于Promise，你可以使用更加优雅的方式编写非阻塞代码。</p>
</blockquote>

<p>使用<code class="highlighter-rouge">co</code>，前面的示例代码，我们可以使用下面的代码来改写：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>co(function* (){  
	yield Something.save();
}).then(function() {
	// success
})
  .catch(function(err) {
	//error handling
});
</code></pre>
</div>

<p>你可能会问：如何实现并行操作呢？答案可能比你想象的简单，如下（其实它就是<code class="highlighter-rouge">Promise.all</code>而已）：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>yield [Something.save(), Otherthing.save()];  
</code></pre>
</div>

<h2 id="async-await">Async/ await</h2>

<p>在ES7（还未正式标准化）中引入了Async函数的概念，目前如果你想要使用的话，只能借助于<a href="http://babeljs.io/">babel</a>
这样的语法转换器将其转为ES5代码。(提醒一点：我们现在讨论的是<code class="highlighter-rouge">async</code>关键字，而不是NPM中的async包)。</p>

<p>简而言之，使用<code class="highlighter-rouge">async</code>关键字，你可以轻松的达成之前使用生成器和<code class="highlighter-rouge">co</code>函数所做到的工作。当然，除了hack之外。</p>

<p>也许你会问，是否在ES7中有了<code class="highlighter-rouge">async</code>关键字，<code class="highlighter-rouge">yield</code>就变得不是那么重要了？</p>

<p>实际上，使用<code class="highlighter-rouge">yield</code>实现异步也不过是一种hack罢了，<code class="highlighter-rouge">yield</code>意味着懒次序(lazy sequences)和迭代器。
而<code class="highlighter-rouge">await</code>能够完美的分离这两点，首先让<code class="highlighter-rouge">yield</code>用于其最初的目的，其次使用<code class="highlighter-rouge">await</code>来执行异步操作。</p>

<p>在这背后，<code class="highlighter-rouge">async</code>函数实际使用的是Promise，也就是为什么async函数会返回一个Promise的原因。</p>

<p>因此，我们使用<code class="highlighter-rouge">async</code>函数来完成类似于前面代码所完成的工作，可以使用下面这样的方式来重新编写代码：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>async function save(Something) {  
	try {
		await Something.save(); // 等待await后面的代码执行完，类似于yield
	} catch (ex) {
		//error handling
	}
	console.log('success');
} 
</code></pre>
</div>

<p>正如你看到的那样，使用async函数，你需要在函数声明的最前面加上<code class="highlighter-rouge">async</code>关键字。这之后，你可以在
函数内部使用<code class="highlighter-rouge">await</code>关键字了，作用和之前的<code class="highlighter-rouge">yield</code>作用是类似的。</p>

<p>使用<code class="highlighter-rouge">async</code>函数完成并行任务与<code class="highlighter-rouge">yiled</code>的方式非常的相似，唯一不同的是，此时<code class="highlighter-rouge">Promise.all</code>不再是
隐式的，你需要显示的调用它：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>async function save(Something) {  
	await Promise.all[Something.save(), Otherthing.save()]
}
</code></pre>
</div>

<p>Koa也支持<code class="highlighter-rouge">async</code>函数，如果你也在使用koa，那么你现在就可以借助<code class="highlighter-rouge">babel</code>使用这一特性了。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>import koa from koa;  
let app = koa();

app.experimental = true;

app.use(async function (){  
	this.body = await Promise.resolve('Hello Reader!')
})

app.listen(3000);  
</code></pre>
</div>

<h2 id="section">拓展阅读</h2>

<ol>
  <li><a href="https://blog.risingstack.com/hapi-on-steroids-using-generator-functions-with-hapi/">Hapi with generators</a></li>
  <li><a href="https://blog.risingstack.com/introduction-to-koa-generators/">Koa</a></li>
</ol>
</article>
        </div>
    </div><!--#post-content-->

    <div id="ds-comment" class="container">
        <div class="ds-thread" data-thread-key="/posts/evolution-of-javascript-async.html" data-title="异步JavaScript的发展历程"></div>
        <script>
            var duoshuoQuery = {short_name:"wwsun"};  
            (function() {  
                var ds = document.createElement('script');  
                ds.type = 'text/javascript';
                ds.async = true;  
                ds.src = 'http://static.duoshuo.com/embed.js';  
                ds.charset = 'UTF-8';  
                (document.getElementsByTagName('head')[0]
                || document.getElementsByTagName('body')[0]).appendChild(ds);  
            })();
        </script>
    </div><!--#ds-comment-->

    <footer id="colophon" class="site-footer" role="contentinfo">
    <div class="site-info container">
        <div class="row">
            <nav id="menu-social" class="social-icons">
                <ul id="menu-social-items" class="social-menu">
                    <li><a href="https://github.com/twolun" title="Github" class="rss" target="_blank"><i class="social_icon fa fa-github"><span>Github</span></i></a></li>
                    <li><a href="/about.html#wechatQr" title="Wechat" class="facebook" target="_blank"><i class="fa fa-weixin"><span>Wechat</span></i></a></li>
                </ul>
            </nav>
            <nav role="navigation" class="col-md-6">
                <ul id="menu-flat-footer" class="nav footer-nav clearfix">
                    <li><a href="https://github.com/twolun">Github</a></li>
                    <li><a href="http://twolun.github.io/">Blog</a></li>
                </ul>
            </nav>
            <div class="copyright col-md-6">
                <a href="http://twolun.github.io/" title="Sparkling">朱了</a> All rights reserved. Theme by 
                <a href="https://pages.github.com/" target="_blank">Github Pages</a> and <a href="https://jekyllrb.com/" target="_blank">Jekyll</a>
            </div>
        </div>
    </div>
    <!-- .site-info -->
    <div class="scroll-to-top"><i class="fa fa-angle-up"></i></div>
    <!-- .scroll-to-top -->
</footer><!-- #colophon -->



</body>

</html>
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>JavaScript Promise API</title>
    <meta name="description" content="">
    <!--<link rel="stylesheet" href="/assets/css/bootstrap.min.css">-->
    <!--<link rel="stylesheet" href="/assets/css/font-awesome.min.css">-->
    <link rel="icon" type="image/png" href="/favicon.ico">
    <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="http://fonts.useso.com/css?family=Roboto">
    <link rel="stylesheet" href="/assets/css/style.css">
    <link rel="stylesheet" href="/assets/css/syntax-highlight.css">
    
    <link rel="stylesheet" href="/assets/css/proj-layout.css">
    <script src="/assets/js/swiftype.js"></script>
    <!--<script src="/assets/js/jquery.js"></script>-->
    <!--<script src="/assets/js/modernizr.min.js"></script>-->
    <!--<script src="/assets/js/bootstrap.min.js"></script>-->
</head>

<body>
    <header>
    <nav class="navbar navbar-default" role="navigation">
        <div class="container">
            <div class="navbar-header">
                <p class="site-name"><a class="navbar-brand" href="/" title="twolun">双轮行</a></p>
            </div>
            <div class="collapse navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="/">HOME</a></li>
                    <li><a href="/about.html">About</a></li>
                    <li><a href="/project.html">Projects</a></li>
                    <li><a href="/list.html">Posts</a></li>
                    <li><a href="http://wwsun.lofter.com/" target="_blank">Lofter</a></li>
                </ul>
            </div>
        </div>
    </nav>
    <!-- .site-navigation -->
</header>
    <div id="post-content" class="container">
        <br>
        <div class="well">
            <header class="page-header">
                <h1>JavaScript Promise API</h1>
                <p class="post-meta">Feb 24, 2016</p>
            </header>
            <article><p>Promise是抽象异步处理对象以及对其进行各种操作的组件。
本文将会详细的向你介绍如何在JavaScript中借助Promise来简化异步代码流。</p>

<!--more-->

<h2 id="statement">Statement</h2>

<ul>
  <li><strong>作者：</strong> <a href="http://wwsun.github.com">景庄</a>，Web开发者，主要关注JavaScript、Node.js、React、Docker等。</li>
  <li>本文是<a href="http://www.html5rocks.com/en/tutorials/es6/promises/">JavaScript Promise - there and back again</a>改动版</li>
</ul>

<h2 id="section">背景知识</h2>

<p>JavaScript是单线程的，这意味着代码是按顺序执行的。对于浏览器而言，JavaScript代码和其他任务共享一个线程，
不同的浏览器略有差异，但大体上这些和JavaScript共享线程的任务主要包括重绘、更新样式、用户交互等，
所有这些任务操作都会阻塞其他任务。</p>

<p>避免事件阻塞的常用方法是使用事件监听器。我们可以为某些特定事件设置监听器，如果事件发生的话，便立刻触发监听器，
你应该已经习惯使用回调函数来解决这个问题了，例如：</p>

<p>```javascript
var img1 = document.querySelector(‘.img-1’);
img1.addEventListener(‘load’, function() {
  // 图片加载完成
});</p>

<p>img1.addEventListener(‘error’, function() {
  // 出问题了
});
```</p>

<p>上面的代码中，我们添加了两个监听器，请求图片，回调函数只在事件发生的时候才会被触发。但是通过事件机制还存在几个问题：</p>

<ol>
  <li>事件在绑定之前就发生了怎么办？</li>
  <li>在添加监听器之前，图片加载发生了错误怎么办？</li>
</ol>

<p>仅仅是一张图片就存在这么多问题，那么如果有一堆图片要处理，又该怎么办？下面我们就谈谈Promise，一个越来越流行的异步解决方案。</p>

<h2 id="promise">Promise</h2>

<p>JavaScript的一大特点就是会涉及到大量的异步代码。同步代码通常易于理解和调试，而异步代码则具有更好的性能和灵活性。
目前Promise正逐渐称为JavaScript世界的一个重要组成部分，并且很多新的API也都基于Promise进行了实现。
目前已经有一些原生API使用了Promise，包括：</p>

<ul>
  <li><a href="https://davidwalsh.name/javascript-battery-api">Battery API</a></li>
  <li><a href="https://davidwalsh.name/fetch">Fetch API</a></li>
  <li>ServiceWorker API</li>
</ul>

<h3 id="promise-1">什么是Promise</h3>

<p>那么到底什么是Promise呢？<code class="highlighter-rouge">Promise</code>是ES6规范新增的对象，它可以用于延迟计算和异步计算。
一个<code class="highlighter-rouge">Promise</code>对象代表着一个还未完成，但预期会完成的操作。需要记住：</p>

<ul>
  <li>一个Promise要么成功要么失败，并且状态不可变</li>
  <li>可以根据Promise的结果设置特定的回调函数</li>
</ul>

<h3 id="promise-2">Promise的状态</h3>

<p>一个Promise的状态可以是：</p>

<ul>
  <li><strong>等待 pending</strong> - Promise的初始化状态，等待结果</li>
  <li><strong>完成 fullfilled</strong> - 该Promise对应的异步操作成功完成了</li>
  <li><strong>失败 rejected</strong> - 该Promise对应的异步操作失败了</li>
  <li><strong>结束 settled</strong> - 任务完成或失败了</li>
</ul>

<h3 id="section-1">基本使用</h3>

<p><code class="highlighter-rouge">new Promise()</code>构造器应该只被用于传统的异步任务上，例如<code class="highlighter-rouge">setTimeout</code>或<code class="highlighter-rouge">XMLHttpRequest</code>。
通过<code class="highlighter-rouge">new</code>关键字创建一个新的<code class="highlighter-rouge">Promise</code>，它接收一个回调函数作为参数，该回调函数又包括了两个特定的回调函数，
分别被命名为<code class="highlighter-rouge">resolve</code>和<code class="highlighter-rouge">reject</code>，成功后调用<code class="highlighter-rouge">resolve</code>，失败则调用<code class="highlighter-rouge">reject</code>。</p>

<p>根据不同的任务，由开发者来决定<code class="highlighter-rouge">resolve</code>和<code class="highlighter-rouge">reject</code>在函数体内的位置。</p>

<p>```javascript
let p = new Promise(function(resolve, reject) {
  // 执行异步任务
  if(/* good condition */) {
    resolve(‘Success’);
  } else {
    // 传递Error对象的好处是可以包含调用堆栈，便于调试
    reject(Error(‘Failure’));
  }
});</p>

<p>p.then(function(result) {
  // do something with the reuslt
  foo(result);
}， function(err){
  console.error(err);
});
```</p>

<p>使用Promise则非常的简单，可以调用<code class="highlighter-rouge">Promise</code>对象的<code class="highlighter-rouge">then()</code>方法来处理异步计算的结果。<code class="highlighter-rouge">then</code>接收两个回调函数，
分别是成功的回调函数和失败时的回调函数，这两个参数都是可选的。</p>

<p>Promise的使用有两点需要记住的：</p>

<ol>
  <li><code class="highlighter-rouge">then()</code>方法可以链式调用</li>
  <li><code class="highlighter-rouge">catch()</code>方法可以作为错误处理语句的语法糖，相当于<code class="highlighter-rouge">then(undefined, function(error) { ... });</code></li>
</ol>

<p>在具体讲解这两点之前，我们先来看一个例子。下面这个例子用于将<code class="highlighter-rouge">XMLHttpRequest</code>转换为一个基于Promise的接口。
我们以GET请求为例：</p>

<p>```javascript
function get(url) {
  // 返回一个新的 Promise
  return new Promise(function(resolve, reject) {
    // 经典 XHR 操作
    var req = new XMLHttpRequest();
    req.open(‘GET’, url);</p>

<div class="highlighter-rouge"><pre class="highlight"><code>req.onload = function() {
  // 当发生 404 等状况的时候调用此函数
  // 所以先检查状态码
  if (req.status == 200) {
    // 以响应文本为结果，完成此 Promise
    resolve(req.response);
  }
  else {
    // 否则就以状态码为结果否定掉此 Promise
    // （提供一个有意义的 Error 对象）
    reject(Error(req.statusText));
  }
};

// 网络异常的处理方法
req.onerror = function() {
  reject(Error("Network Error"));
};

// 发出请求
req.send();   }); } ```
</code></pre>
</div>

<p>我们现在可以这么调用它：</p>

<p><code class="highlighter-rouge">javascript
get('story.json').then(function(response) {
  console.log("Success!", response);
}, function(error) {
  console.error("Failed!", error);
});
</code></p>

<p>现在我们发起XHR请求便变得简单直观的多了。<code class="highlighter-rouge">story.json</code>文件的内容如下：</p>

<p><code class="highlighter-rouge">json
{
  "heading": "&lt;h1&gt;A story about something&lt;/h1&gt;",
  "chapterUrls": [
    "chapter-1.json",
    "chapter-2.json",
    "chapter-3.json",
    "chapter-4.json",
    "chapter-5.json"
  ]
}
</code></p>

<h3 id="promiseresolve"><code class="highlighter-rouge">Promise.resolve</code></h3>

<p>有时你无需在promise内完成一个异步任务——如果一个异步动作被执行是可能的话，然而，返回一个Promise是将是最合适的，
因此你可以总是期望从给定函数中产生的promise。在这种情况下，你可以简单的调用<code class="highlighter-rouge">Promise.resolve()</code>或者<code class="highlighter-rouge">Promise.reject()</code>，
而无需<code class="highlighter-rouge">new</code>关键字。例如：</p>

<p>```javascript
var userCache = {};
function getUserDetail(username) {
  // 两种情况下，要么缓存要么不缓存，都将返回一个promise</p>

<p>if (userCache[username]) {
    // 不使用new关键字返回一个promise
    return Promise.resolve(userCache[username]);
  }</p>

<p>// 使用fetch API获取信息
  // fetch返回一个promise
  return fetch(‘user/’ + username + ‘.json’)
    .then(result =&gt; {
      userCache[username] = result;
      return result;
    })
    .catch(() =&gt; {
      throw new Error(‘Could not find user: ‘ + username);
    });
}
```</p>

<p>由于返回的是一个Promise，你可以在返回值上使用<code class="highlighter-rouge">then</code>和<code class="highlighter-rouge">catch</code>方法。
可以将<code class="highlighter-rouge">Promise.resolve</code>看作是<code class="highlighter-rouge">new Promise()</code>的快捷方式。</p>

<h3 id="section-2">链式调用</h3>

<p>上面我们说过<code class="highlighter-rouge">then()</code>接收两个参数，分别对应成功和失败时的回调函数。我们还可以将多个<code class="highlighter-rouge">then</code>方法串联起来，
用于修改结果或执行更多的异步操作。</p>

<p>你可以对结果进行修改，然后返回一个新的值，例如：</p>

<p>```javascript
new Promise(function(resolve, reject) { 
	// A mock async action using setTimeout
	setTimeout(function() { resolve(10); }, 3000);
})
.then(num =&gt; { console.log(‘first then: ‘, num); return num * 2; })
.then(num =&gt; { console.log(‘second then: ‘, num); return num * 2; })
.then(num =&gt; { console.log(‘last then: ‘, num);});</p>

<p>// From the console:
// first then:  10
// second then:  20
// last then:  40
```</p>

<p>每个<code class="highlighter-rouge">then</code>接收前一个<code class="highlighter-rouge">then</code>的返回值的结果。</p>

<p>回到之前的<code class="highlighter-rouge">get</code>函数，我们可以修改返回值的类型，将结果进行一定的转换：</p>

<p><code class="highlighter-rouge">javascript
get('story.json').then(function(response) {
  return JSON.parse(response);
}).then(function(response) {
  console.log("Yey JSON!", response);
});
</code></p>

<p>为了让代码变得更简单，可以再次进行改进：</p>

<ul>
  <li>因为<code class="highlighter-rouge">JSON.parse</code>只接收一个参数，并返回转换后的结果，我们可以直接使用<code class="highlighter-rouge">then(JSON.parse)</code></li>
  <li><code class="highlighter-rouge">then</code>中的回调函数，我们可以直接使用ES6的胖箭头函数，这样可以让代码更直观</li>
</ul>

<p><code class="highlighter-rouge">javascript
get('story.json').then(JSON.parse).then(response =&gt; console.log("JSON data: ", response);
</code></p>

<p>由于这段代码会被重复调用，我们可以定义一个新的<code class="highlighter-rouge">getJSON</code>函数：</p>

<p><code class="highlighter-rouge">javascript
function getJSON(url) {
  return get(url).then(JSON.parse);  // 返回一个获取JSON并加以解析的Promise
}
</code></p>

<p>对于串联起来的<code class="highlighter-rouge">then()</code>方法而言：如果你返回了一个值，那么它就会被传给下一个<code class="highlighter-rouge">then()</code>的回调。
如果你返回一个“类Promise”对象，则下一个<code class="highlighter-rouge">then()</code>就会等待这个Promise明确结束（成功/失败）才会执行。</p>

<p><code class="highlighter-rouge">javascript
getJSON('story.json')
  .then(story =&gt; getJSON(story.chapterUrls[0]))
  .then(chapter =&gt; console.log("Got chapter 1!, " chapter));
</code></p>

<p>在上面的代码中，我们首先发起对<code class="highlighter-rouge">story.json</code>的异步请求，它会返回给我们一个URL列表，然后我们请求其中的第一个，。</p>

<h3 id="section-3">错误处理</h3>

<p>前面我们已经知道，<code class="highlighter-rouge">then</code>接收两个参数，一个处理成功时的回调函数，一个处理失败时的回调函数。</p>

<p><code class="highlighter-rouge">javascript
get('story.json').then(function(response) {
  console.log("Success!", response);
}, function(error) {
  console.log("Failed!", error);
});
</code></p>

<p>你还可以使用<code class="highlighter-rouge">catch</code>来进行错误处理，实际上，它不过是<code class="highlighter-rouge">then(undefined, func)</code>的语法糖而已。这样能够让代码更直观：</p>

<p><code class="highlighter-rouge">javascript
get('story.json')
  .then(response =&gt; console.log('Success!', response))
  .catch(error =&gt; console.error('Failed!', error));
</code></p>

<h2 id="section-4">并行和串行</h2>

<p>异步意味着你不用等待前一件事情做完就可以做后一件事。现在，我们想要遍历所有章节的URL并且依次请求，应该怎么办？
使用传统的方法，你可能会想到<code class="highlighter-rouge">array.forEach</code>：</p>

<p><code class="highlighter-rouge">javascript
story.chapterUrls.forEach(chapterUrl =&gt; {
  // getJSON是异步操作
  getJSON(chapterUrl).then(chapter =&gt; { 
    addHtmlToPage(chapter.html)
  });
});
</code></p>

<p>但是这么做并不可行，因为<code class="highlighter-rouge">forEach</code>并<strong>不支持异步操作</strong>！</p>

<h3 id="promise-3">Promise序列</h3>

<p><code class="highlighter-rouge">javascript
// 遍历所有章节的 url
story.chapterUrls.reduce(function(sequence, chapterUrl) {
  // 从 sequence 开始把操作接龙起来
  return sequence.then(() =&gt; getJSON(chapterUrl))
    .then(chapter =&gt; { 
      addHtmlToPage(chapter.html) ;
    });
}, Promise.resolve());
</code></p>

<p>上面的代码中使用了<code class="highlighter-rouge">Promise.resolve()</code>，它会依据你传入的任何值返回一个Promise。
如果你传给它一个类Promise对象（带有<code class="highlighter-rouge">then</code>方法），它会生成一个带有同样肯定/否定回调的Promsie。
如果你传给它任何别的值，如<code class="highlighter-rouge">Promise.resolve('hello')</code>，它会创建一个以该值为完成结果的<code class="highlighter-rouge">Promise</code>，
如过不传入任何值，则以<code class="highlighter-rouge">undefined</code>为完成结果。</p>

<p><code class="highlighter-rouge">reduce</code>回调会一次应用在每一个数组元素上，第一轮的<code class="highlighter-rouge">sequence</code>是<code class="highlighter-rouge">Promise.resolve()</code>，
之后的调用里<code class="highlighter-rouge">sequence</code>就是上次函数执行的结果。<code class="highlighter-rouge">reduce()</code>方法非常适合用于把一个值归并处理为一个值。</p>

<p><code class="highlighter-rouge">Array.prototype.reduce(callback, [initialValue])</code>方法接收一个函数作为累加器，数组中的每个值（从左到右）开始合并，
最终为一个值。参数二作为第一次调用callback的第一个参数。此外，callback包括四个参数：</p>

<ul>
  <li>previousValue - 上一次调用回调返回的值，或者是提供的初始值（initialValue）</li>
  <li>currentValue - 数组中当前被处理的元素</li>
  <li>index - 当前元素在数组中的索引</li>
  <li>array - 调用reduce的数组</li>
</ul>

<p>汇总前面的代码为：</p>

<p><code class="highlighter-rouge">javascript
getJSON('story.json')
  .then(story =&gt; {
    addHtmlToPage(story.heading);
    return story.chapterUrls.reduce((sequence, chapterUrl) =&gt; {
      return sequence.then(() =&gt; getJSON(chapterUrl))
      .then(chapter =&gt; addHtmlToPage(chapter.html));
    }, Promise.resolve());
  })
  .then(() =&gt; addTextToPage('All done'))
  .catch(err =&gt; addTextToPage('Argh, broken: ' + err.message))
  .then(() =&gt; document.querySelector('.spinner').style.display = 'none');
</code></p>

<p>辅助方法定义如下：</p>

<p>```javascript
var storyDiv = document.querySelector(‘.story’);</p>

<p>function addHtmlToPage (html) {
  var div = document.createElement(‘div’);
  div.innerHTML = html;
  storyDiv.appendChild(div);
}</p>

<p>function addTextToPage (text) {
  var p = document.createElement(‘p’);
  p.textContent = text;
  storyDiv.appendChild(p);
}
```</p>

<h3 id="promiseall"><code class="highlighter-rouge">Promise.all</code></h3>

<p>浏览器很擅长同时加载多个文件，上面的方法属于一个接一个下载章节，这先得非常的低效。我们希望同时下载所有章节，
全部完成后一次搞定，正好就有这么个API：</p>

<p><code class="highlighter-rouge">javascript
Promise.all(arrayOfPromise).then(arrayOfResults =&gt; {} );
</code></p>

<p><code class="highlighter-rouge">Promise.all</code>接收一个Promise数组作为参数，创建一个当所有Promise都完成之后就完成的Promise，它的完成结果是一个数组，
包含了所有先前传入的那些Promise的完成结果，顺序和将它们传入的数组顺序一致。</p>

<p><code class="highlighter-rouge">javascript
getJSON('story.json').then(story =&gt; {
  addHtmlToPage(story.heading);
  // 接收一个Promise数组并等待他们全部结束
  // 把章节URL数组转换成对应的Promise数组
  return Promise.all(story.chapterUrls.map(getJSON));
}).then(chapters =&gt; {
  // 现在我们有了顺序的章节JSON，遍历它们
  // 并添加到页面中
  chapters.forEach(chapter =&gt; addHtmlToPage(chapter.html));
  addTextToPage('All done');
})
  // 捕获过程中的任何错误
  .catch(err =&gt; addTextToPage('Argh, broken: ' + err.message))
  .then(() =&gt; document.querySelector('.spinner').style.display = 'none');
</code></p>

<p>根据连接状况，改进的代码会比顺序加载方式提速数秒，甚至代码行数也更少。章节加载完成的顺序不确定，
但它们显示在页面上的顺序准确无误。</p>

<p>但仍然有改进空间：第一章内容加载完成后，我们向让它立即填进页面，这样用户可以在其他加载任务尚未完成之前就开始阅读。
当第三章到达的时候我们不动声色，第二章也到达之后我们再把第二章和第三章内容填入页面，以此类推。</p>

<p>为了达到这个效果，我们同时请求所有的章节内容，然后创建一个序列依次将其填入页面：</p>

<p>```javascript
getJSON(‘story.json’)
  .then(story =&gt; {
    addHtmlToPage(story.heading);</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// 把章节 URL 数组转换成对应的 Promise 数组
// 这样就可以并行加载它们
return story.chapterUrls.map(getJSON)
  .reduce((sequence, chapterPromise) =&gt; {

    // 使用 reduce 把这些 Promise 接龙
    // 以及将章节内容添加到页面
    return sequence

      // 等待当前 sequence 中所有章节和本章节的数据到达
      .then(() =&gt; chapterPromise)
      .then(chapter =&gt; { addHtmlToPage(chapter.html) });
  }, Promise.resolve());   })   .then(() =&gt; { addTextToPage("All done") })   // 捕获过程中的任何错误   .catch(err =&gt; { addTextToPage("Argh, broken: " + err.message) })   .then(() =&gt; { document.querySelector('.spinner').style.display = 'none' }); ```
</code></pre>
</div>

<h2 id="references">References</h2>

<ol>
  <li><a href="https://davidwalsh.name/promises">JavaScript Promise API</a></li>
  <li><a href="http://www.html5rocks.com/zh/tutorials/es6/promises">JavaScript Promise: There and Back Again</a></li>
  <li><a href="http://liubin.org/promises-book/">Promise迷你书</a></li>
  <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">MDN: Promise</a></li>
</ol>
</article>
        </div>
    </div><!--#post-content-->

    <div id="ds-comment" class="container">
        <div class="ds-thread" data-thread-key="/posts/javascript-promise-api.html" data-title="JavaScript Promise API"></div>
        <script>
            var duoshuoQuery = {short_name:"wwsun"};  
            (function() {  
                var ds = document.createElement('script');  
                ds.type = 'text/javascript';
                ds.async = true;  
                ds.src = 'http://static.duoshuo.com/embed.js';  
                ds.charset = 'UTF-8';  
                (document.getElementsByTagName('head')[0]
                || document.getElementsByTagName('body')[0]).appendChild(ds);  
            })();
        </script>
    </div><!--#ds-comment-->

    <footer id="colophon" class="site-footer" role="contentinfo">
    <div class="site-info container">
        <div class="row">
            <nav id="menu-social" class="social-icons">
                <ul id="menu-social-items" class="social-menu">
                    <li><a href="https://github.com/wwsun" title="Github" class="rss" target="_blank"><i class="social_icon fa fa-github"><span>Github</span></i></a></li>
                    <li><a href="http://weibo.com/234170023" title="Weibo" class="youtube" target="_blank"><i class="social_icon fa fa-weibo"><span>Weibo</span></i></a></li>
                    <li><a href="https://twitter.com/wsun38" title="Twitter" class="twitter" target="_blank"><i class="social_icon fa fa-twitter"><span>Twitter</span></i></a></li>
                    <li><a href="https://plus.google.com/u/0/101153267739962807712/posts" title="Google+" class="googleplus" target="_blank"><i class="social_icon fa fa-googleplus"><span>GooglePlus</span></i></a></li>
                    <li><a href="/about.html#wechatQr" title="Wechat" class="facebook" target="_blank"><i class="fa fa-weixin"><span>Wechat</span></i></a></li>
                </ul>
            </nav>
            <nav role="navigation" class="col-md-6">
                <ul id="menu-flat-footer" class="nav footer-nav clearfix">
                    <li><a href="http://weibo.com/swwol">Weibo</a></li>
                    <li><a href="https://github.com/wwsun">Github</a></li>
                    <li><a href="http://www.zhihu.com/people/wwsun">Zhihu</a></li>
                    <li><a href="http://www.youtube.com/user/bootstrapbayofficial">Lofter</a></li>
                    <li><a href="http://wwsun.github.io/">Blog</a></li>
                </ul>
            </nav>
            <div class="copyright col-md-6">
                <a href="http://wwsun.github.io/" title="Sparkling">Weiwei SUN</a> All rights reserved. Theme by 
                <a href="http://colorlib.com/" target="_blank">Colorlib</a> Powered by
                <a href="https://pages.github.com/" target="_blank">Github Pages</a> and <a href="https://jekyllrb.com/" target="_blank">Jekyll</a>
            </div>
        </div>
    </div>
    <!-- .site-info -->
    <div class="scroll-to-top"><i class="fa fa-angle-up"></i></div>
    <!-- .scroll-to-top -->
</footer><!-- #colophon -->

<!-- Google Tag Manager -->
<noscript>
    <iframe src="//www.googletagmanager.com/ns.html?id=GTM-KJHNXB" height="0" width="0" style="display:none;visibility:hidden"></iframe>
</noscript>

<script>
    (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KJHNXB');
</script>
<!-- End Google Tag Manager -->

</body>

</html>